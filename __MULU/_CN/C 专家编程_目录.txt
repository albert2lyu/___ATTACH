
目　录

第1章　C：穿越时空的迷雾　1
1.1　C语言的史前阶段　1
1.2　C语言的早期体验　4
1.3　标准I/O库和C预处理器　5
1.4　K&R C　8
1.5　今日之ANSI C　10
1.6　它很棒，但它符合标准吗　12
1.7　编译限制　14
1.8　ANSI C标准的结构　15
1.9　阅读ANSI C标准，寻找乐趣和裨益　19
1.10　“安静的改变”究竟有多少安静　22
1.11　轻松一下――由编译器定义的Pragmas效果　25

第2章　这不是Bug，而是语言特性　27
2.1　这关语言特性何事，在Fortran里这就是Bug呀　27
2.2　多做之过　29
2.3　误做之过　36
2.4　少做之过　43
2.5　轻松一下――有些特性确实就是Bug　51
2.6　参考文献　53

第3章　分析C语言的声明　55
3.1　只有编译器才会喜欢的语法　56
3.2　声明是如何形成的　58
3.3　优先级规则　63
3.4　通过图表分析C语言的声明　65
3.5　typedef可以成为你的朋友　67
3.6　typedef int x[10]和#define x int[10]的区别　68
3.7　typedef struct foo{ ... foo; }的含义　69
3.8　理解所有分析过程的代码段　71
3.9　轻松一下――驱动物理实体的软件　73

第4章　令人震惊的事实：数组和指针并不相同　81
4.1　数组并非指针　81
4.2　我的代码为什么无法运行　81
4.3　什么是声明，什么是定义　82
4.4　使声明与定义相匹配　86
4.5　数组和指针的其他区别　86
4.6　轻松一下――回文的乐趣　88

第5章　对链接的思考　91
5.1　函数库、链接和载入　91
5.2　动态链接的优点　94
5.3　函数库链接的5个特殊秘密　98
5.4　警惕Interpositioning　102
5.5　产生链接器报告文件　107
5.6　轻松一下――看看谁在说话：挑战Turing测验　108

第6章　运动的诗章：运行时数据结构　115
6.1　a.out及其传说　116
6.2　段　117
6.3　操作系统在a.out文件里干了些什么　119
6.4　C语言运行时系统在a.out里干了些什么　121
6.5　当函数被调用时发生了什么：过程活动记录　123
6.6　auto和static关键字　126
6.7　控制线程　128
6.8　setjmp和longjmp　128
6.9　UNIX中的堆栈段　130
6.10　MS-DOS中的堆栈段　130
6.11　有用的C语言工具　131
6.12　轻松一下――卡耐基-梅隆大学的编程难题　134
6.13　只适用于高级学员阅读的材料　136

第7章　对内存的思考　137
7.1　Intel 80x86系列　137
7.2　Intel 80x86内存模型以及它的工作原理　141
7.3　虚拟内存　145
7.4　Cache存储器　148
7.5　数据段和堆　152
7.6　内存泄漏　153
7.7　总线错误　157
7.8　轻松一下――“Thing King”和“页面游戏”　163

第8章　为什么程序员无法分清万圣节和圣诞节　169
8.1　Portzebie度量衡系统　169
8.2　根据位模式构筑图形　170
8.3　在等待时类型发生了变化　172
8.4　原型之痛　174
8.5　原型在什么地方会失败　176
8.6　不需要按回车键就能得到一个字符　179
8.7　用C语言实现有限状态机　183
8.8　软件比硬件更困难　185
8.9　如何进行强制类型转换，为何要进行类型强制转换　187
8.10　轻松一下――国际C语言混乱代码大赛　189

第9章　再论数组　199
9.1　什么时候数组与指针相同　199
9.2　为什么会发生混淆　200
9.3　为什么C语言把数组形参当作指针　205
9.4　数组片段的下标　208
9.5　数组和指针可交换性的总结　209
9.6　C语言的多维数组　209
9.7　轻松一下――软件/硬件平衡　215

第10章　再论指针　219
10.1　多维数组的内存布局　219
10.2　指针数组就是Iliffe向量　220
10.3　在锯齿状数组上使用指针　223
10.4　向函数传递一个一维数组　226
10.5　使用指针向函数传递一个多维数组　227
10.6　使用指针从函数返回一个数组　230
10.7　使用指针创建和使用动态数组　232
10.8　轻松一下――程序检验的限制　237

第11章　你懂得C，所以C++不在话下　241
11.1　初识OOP　241
11.2　抽象――取事物的本质特性　243
11.3　封装――把相关的类型、数据和函数组合在一起　245
11.4　展示一些类――用户定义类型享有和预定义类型一样的权限　246
11.5　访问控制　247
11.6　声明　247
11.7　如何调用成员函数　249
11.8　继承――复用已经定义的操作　251
11.9　多重继承――从两个或更多的基类派生　255
11.10　重载――作用于不同类型的同一操作具有相同的名字　256
11.11　C++如何进行操作符重载　257
11.12　C++的输入/输出(I/O)　258
11.13　多态――运行时绑定　258
11.14　解释　260
11.15　C++如何表现多态　261
11.16　新奇玩意――多态　262
11.17　C++的其他要点　263
11.18　如果我的目标是那里，我不会从这里起步　264
11.19　它或许过于复杂，但却是惟一可行的方案　266
11.20　轻松一下――死亡计算机协会　270
11.21　更多阅读材料　271

附录A　程序员工作面试的秘密　273
附录B　术语表　285
