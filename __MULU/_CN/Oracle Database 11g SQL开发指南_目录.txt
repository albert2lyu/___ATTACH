
目    录
第1章  简介	1
1.1  关系数据库简介	2
1.2  结构化查询语言(SQL)简介	2
1.3  使用SQL*Plus	4
1.3.1  启动SQL*Plus	4
1.3.2  从命令行启动SQL*Plus	5
1.3.3  使用SQL*Plus执行SELECT
语句	6
1.4  SQL Developer	7
1.5  创建store模式	9
1.5.1  运行SQL*Plus脚本创建store
模式	9
1.5.2  用来创建store模式的DDL
语句	10
1.6  添加、修改、删除行	18
1.6.1  向表中添加行	18
1.6.2  修改表中的现有行	19
1.6.3  从表中删除行	20
1.7  BINARY_FLOAT和BINARY_ 
DOUBLE数据类型	21
1.7.1  BINARY_FLOAT和
BINARY_DOUBLE的优点	21
1.7.2  在表中使用BINARY_FLOAT
和BINARY_DOUBLE	21
1.7.3  特殊值	22
1.8  退出SQL*Plus	23
1.9  Oracle PL/SQL简介	23
1.10  小结	24
第2章  从数据库表中检索信息	25
2.1  对单表执行SELECT语句	25
2.2  选择一个表中的所有列	26
2.3  使用WHERE子句过滤行	27
2.4  理解行标识符	27
2.5  理解行号	28
2.6  执行算术运算	28
2.6.1  日期运算	29
2.6.2  列运算	30
2.7  使用列别名	31
2.8  使用连接操作合并列的输出
结果	32
2.9  理解空值	33
2.10  禁止显示重复行	34
2.11  比较值	35
2.12  使用SQL操作符	37
2.12.1  使用LIKE操作符	37
2.12.2  使用IN操作符	38
2.12.3  使用BETWEEN操作符	39
2.13  使用逻辑操作符	40
2.14  理解操作符的优先级	41
2.15  使用ORDER BY子句对行
进行排序	41
2.16  执行使用两个表的SELECT
语句	42
2.17  使用表别名	44
2.18  笛卡尔积	45
2.19  执行使用多于两个表的
SELECT语句	46
2.20  连接条件和连接类型	47
2.20.1  不等连接	47
2.20.2  外连接	48
2.20.3  自连接	51
2.21  使用SQL/92语法执行连接	52
2.21.1  使用SQL/92标准语法执行
两个表的内连接	53
2.21.2  使用USING关键字简化
连接	53
2.21.3  使用SQL/92执行多于两个
表的内连接	54
2.21.4  使用SQL/92执行多列的
内连接	55
2.21.5  使用SQL/92执行外连接	55
2.21.6  使用SQL/92执行自连接	56
2.21.7  使用SQL/92执行交叉
连接	57
2.22  小结	57
第3章  使用SQL*Plus	59
3.1  查看表结构	60
3.2  编辑SQL语句	60
3.3  保存、检索并运行文件	62
3.4  格式化列	65
3.5  设置页面大小	67
3.6  设置行大小	68
3.7  清除列格式	68
3.8  使用变量	69
3.8.1  临时变量	69
3.8.2  已定义变量	72
3.9  创建简单报表	74
3.9.1  在脚本中使用临时变量	74
3.9.2  在脚本中使用已定义变量	75
3.9.3  向脚本中的变量传递值	75
3.9.4  添加页眉和页脚	76
3.9.5  计算小计	78
3.10  从SQL*Plus获取帮助信息	79
3.11  自动生成SQL语句	80
3.12  断开数据库连接并退出
SQL*Plus	81
3.13  小结	81
第4章  使用简单函数	83
4.1  使用单行函数	84
4.1.1  字符函数	84
4.1.2  数字函数	92
4.1.3  转换函数	96
4.1.4  正则表达式函数	102
4.2  使用聚合函数	108
4.2.1  AVG函数	109
4.2.2  COUNT函数	110
4.2.3  MAX和MIN函数	110
4.2.4  STDDEV函数	111
4.2.5  SUM函数	111
4.2.6  VARIANCE函数	112
4.3  对行进行分组	112
4.3.1  使用GROUP BY子句对行
进行分组	112
4.3.2  调用聚合函数的错误用法	115
4.3.3  使用HAVING子句过滤
行组	116
4.3.4  组合使用WHERE和GROUP 
BY子句	117
4.3.5  组合使用WHERE、GROUP 
BY和HAVING子句	117
4.4  小结	118
第5章  日期和时间的存储与处理	119
5.1  几个简单的存储和检索日期的
例子	120
5.2  使用TO_CHAR()和
TO_DATE()转换时间值	121
5.2.1  使用TO_CHAR()将时间值
转换为字符串	121
5.2.2  使用TO_DATE()将字符串
转换为时间值	125
5.3  设置默认的日期格式	128
5.4  Oracle对2位年份的处理	129
5.4.1  使用YY格式	129
5.4.2  使用RR格式	130
5.5  使用时间值函数	131
5.5.1  ADD_MONTHS函数	131
5.5.2  LAST_DAY函数	132
5.5.3  MONTHS_BETWEEN函数	133
5.5.4  NEXT_DAY函数	133
5.5.5  ROUND函数	133
5.5.6  SYSDATE	134
5.5.7  TRUNC函数	134
5.6  理解时区	135
5.6.1  与时区有关的函数	136
5.6.2  数据库时区和会话时区	136
5.6.3  获取时区的时差	137
5.6.4  获取时区名	138
5.6.5  将时间值从一个时区转换为
另一个时区	138
5.7  使用时间戳	139
5.7.1  使用时间戳类型	139
5.7.2  与时间戳有关的函数	143
5.8  使用时间间隔	148
5.8.1  使用INTERVAL YEAR TO 
MONTH类型	149
5.8.2  使用INTERVAL DAY TO 
SECOND类型	150
5.8.3  与时间间隔有关的函数	152
5.9  小结	153
第6章  子查询	155
6.1  子查询的类型	155
6.2  编写单行子查询	156
6.2.1  在WHERE子句中使用
子查询	156
6.2.2  使用其他单行操作符	157
6.2.3  在HAVING子句中使用
子查询	157
6.2.4  在FROM子句中使用子查询
(内联视图)	159
6.2.5  可能碰到的错误	159
6.3  编写多行子查询	160
6.3.1  在多行子查询中使用IN
操作符	161
6.3.2  在多行子查询中使用ANY
操作符	162
6.3.3  在多行子查询中使用ALL
操作符	162
6.4  编写多列子查询	162
6.5  编写关联子查询	163
6.5.1  关联子查询的例子	163
6.5.2  在关联子查询中使用EXISTS
和NOT EXISTS	164
6.6  编写嵌套子查询	166
6.7  编写包含子查询的UPDATE
和DELETE语句	168
6.7.1  编写包含子查询的UPDATE
语句	168
6.7.2  编写包含子查询的DELETE
语句	168
6.8  小结	169
第7章  高级查询	171
7.1  使用集合操作符	172
7.1.1  示例表	172
7.1.2  使用UNION ALL操作符	173
7.1.3  使用UNION操作符	174
7.1.4  使用INTERSECT操作符	175
7.1.5  使用MINUS操作符	175
7.1.6  组合使用集合操作符	176
7.2  使用TRANSLATE函数	178
7.3  使用DECODE()函数	179
7.4  使用CASE表达式	181
7.4.1  使用简单CASE表达式	181
7.4.2  使用搜索CASE表达式	182
7.5  层次化查询	183
7.5.1  示例数据	183
7.5.2  使用CONNECT BY和
START WITH子句	185
7.5.3  使用伪列LEVEL	185
7.5.4  格式化层次化查询的结果	186
7.5.5  从非根节点开始遍历	187
7.5.6  在START WITH子句中
使用子查询	187
7.5.7  从下向上遍历树	188
7.5.8  从层次查询中删除节点和
分支	188
7.5.9  在层次化查询中加入其他
条件	189
7.6  使用扩展的GROUP BY子句	190
7.7  使用ROLLUP子句	192
7.7.1  使用CUBE子句	194
7.7.2  使用GROUPING函数	195
7.7.3  使用GROUPING SETS子句	198
7.7.4  使用GROUPING_ID函数	199
7.7.5  在GROUP BY子句中多次
使用一个列	201
7.7.6  使用GROUP_ID函数	201
7.8  使用分析函数	203
7.8.1  示例表	203
7.8.2  使用评级函数	204
7.8.3  使用反百分点函数	211
7.8.4  使用窗口函数	211
7.8.5  使用报表函数	216
7.8.6  使用LAG和LEAD函数	218
7.8.7  使用FIRST和LAST函数	219
7.8.8  使用线性回归函数	219
7.8.9  使用假想评级与分布函数	221
7.9  使用MODEL子句	221
7.9.1  MODEL子句示例	222
7.9.2  用位置标记和符号标记访问
数据单元	223
7.9.3  用BETWEEN和AND返回
特定范围内的数据单元	224
7.9.4  用ANY和IS ANY访问所有
的数据单元	224
7.9.5  用CURRENTV()获取某个
维度的当前值	225
7.9.6  用FOR循环访问数据单元	226
7.9.7  处理空值和缺失值	227
7.9.8  更新已有的单元	229
7.10  使用PIVOT和UNPIVOT
子句	230
7.10.1  PIVOT子句示例	230
7.10.2  转换多个列	231
7.10.3  在转换中使用多个聚合
函数	232
7.10.4  使用UNPIVOT子句	233
7.11  小结	234
第8章  修改表的内容	237
8.1  使用INSERT语句添加行	237
8.1.1  省略列的列表	239
8.1.2  为列指定空值	239
8.1.3  在列值中使用单引号和
双引号	239
8.1.4  从一个表向另外一个表
复制行	239
8.2  使用UPDATE语句修改行	240
8.3  RETURNING子句	241
8.4  使用DELETE语句删除行	242
8.5  数据库的完整性	242
8.5.1  主键约束	242
8.5.2  外键约束	243
8.6  使用默认值	244
8.7  使用MERGE合并行	245
8.8  数据库事务	247
8.8.1  事务的提交和回滚	247
8.8.2  事务的开始与结束	248
8.8.3  保存点	249
8.8.4  事务的ACID特性	251
8.8.5  并发事务	251
8.8.6  事务锁	252
8.8.7  事务隔离级别	253
8.8.8  SERIALIZABLE事务的一个
例子	254
8.9  查询闪回	254
8.9.1  使用闪回的授权	254
8.9.2  时间查询闪回	255
8.9.3  系统变更号查询闪回	256
8.10  小结	258
第9章  用户、特权和角色	259
9.1  用户	260
9.1.1  创建用户	260
9.1.2  修改用户密码	261
9.1.3  删除用户	261
9.2  系统特权	262
9.2.1  向用户授予系统特权	263
9.2.2  检查授予用户的系统特权	263
9.2.3  使用系统特权	264
9.2.4  撤消用户的系统特权	264
9.3  对象特权	265
9.3.1  向用户授予对象特权	265
9.3.2  检查已授予的对象特权	266
9.3.3  检查已接受的对象特权	267
9.3.4  使用对象特权	269
9.3.5  同名对象	269
9.3.6  公共同名对象	270
9.3.7  撤消用户的对象特权	271
9.4  角色	271
9.4.1  创建角色	271
9.4.2  为角色授权	272
9.4.3  将角色授予用户	272
9.4.4  检查授予用户的角色	273
9.4.5  检查授予角色的系统特权	274
9.4.6  检查授予角色的对象特权	274
9.4.7  使用授予角色的特权	276
9.4.8  默认角色	276
9.4.9  撤消角色	277
9.4.10  从角色中撤消特权	277
9.4.11  删除角色	277
9.5  审计	277
9.5.1  执行审计需要的特权	277
9.5.2  审计示例	278
9.5.3  审计跟踪视图	279
9.6  小结	280
第10章  创建表、序列、索引和视图	281
10.1  表	282
10.1.1  创建表	282
10.1.2  获得有关表的信息	283
10.1.3  获得表中列的信息	284
10.1.4  修改表	285
10.1.5  重命名表	294
10.1.6  向表中添加注释	294
10.1.7  截断表	295
10.1.8  删除表	295
10.2  序列	295
10.2.1  创建序列	295
10.2.2  获取有关序列的信息	297
10.2.3  使用序列	298
10.2.4  使用序列填充主键	299
10.2.5  修改序列	300
10.2.6  删除序列	301
10.3  索引	301
10.3.1  创建B-树索引	302
10.3.2  创建基于函数的索引	303
10.3.3  获取有关索引的信息	303
10.3.4  获取列索引的信息	304
10.3.5  修改索引	304
10.3.6  删除索引	305
10.3.7  创建位图索引	305
10.4  视图	305
10.4.1  创建并使用视图	306
10.4.2  修改视图	313
10.4.3  删除视图	314
10.5  闪回数据归档	314
10.6  小结	316
第11章  PL/SQL编程简介	317
11.1  块结构	318
11.2  变量和类型	319
11.3  条件逻辑	320
11.4  循环	320
11.4.1  简单循环	321
11.4.2  WHILE循环	322
11.4.3  FOR循环	322
11.5  游标	323
11.5.1  步骤1：声明用于保存列值
的变量	323
11.5.2  步骤2：声明游标	323
11.5.3  步骤3：打开游标	324
11.5.4  步骤4：从游标中取得
记录	324
11.5.5  步骤5：关闭游标	325
11.5.6  完整的示例：
product_cursor.sql	325
11.5.7  游标与FOR循环	326
11.5.8  OPEN-FOR语句	327
11.5.9  无约束游标	329
11.6  异常	330
11.6.1  ZERO_DIVIDE异常	332
11.6.2  DUP_VAL_ON_INDEX
异常	333
11.6.3  INVALID_NUMBER
异常	333
11.6.4  OTHERS异常	333
11.7  过程	334
11.7.1  创建过程	334
11.7.2  调用过程	337
11.7.3  获取有关过程的信息	338
11.7.4  删除过程	338
11.7.5  查看过程中的错误	338
11.8  函数	339
11.8.1  创建函数	339
11.8.2  调用函数	340
11.8.3  获取有关函数的信息	341
11.8.4  删除函数	341
11.9  包	341
11.9.1  创建包规范	342
11.9.2  创建包体	342
11.9.3  调用包中的函数和过程	344
11.9.4  获取有关包中函数和过程
的信息	344
11.9.5  删除包	345
11.10  触发器	345
11.10.1  触发器运行的时机	345
11.10.2  设置示例触发器	345
11.10.3  创建触发器	346
11.10.4  激活触发器	347
11.10.5  获取有关触发器的信息	348
11.10.6  禁用和启用触发器	350
11.10.7  删除触发器	350
11.11  Oracle Database 11g新增加的
PL/SQL特性	350
11.11.1  SIMPLE_INTEGER
类型	350
11.11.2  在PL/SQL中使用序列	351
11.11.3  PL/SQL本地机器代码
生成	352
11.12  小结	353
第12章  数据库对象	355
12.1  对象简介	356
12.2  创建对象类型	356
12.3  使用DESCRIBE获取有关
对象类型的信息	358
12.4  在数据库表中使用对象类型	359
12.4.1  列对象	359
12.4.2  对象表	361
12.4.3  对象标识符和对象引用	365
12.4.4  比较对象值	367
12.5  在PL/SQL中使用对象	369
12.5.1  get_products()函数	370
12.5.2  display_product()过程	371
12.5.3  insert_product()过程	372
12.5.4  update_product_price()
过程	373
12.5.5  get_product()函数	373
12.5.6  update_product()过程	374
12.5.7  get_product_ref()函数	375
12.5.8  delete_product()过程	375
12.5.9  product_lifecycle()过程	376
12.5.10  product_lifecycle2()过程	377
12.6  类型继承	378
12.7  用子类型对象代替超类型
对象	380
12.7.1  SQL例子	380
12.7.2  PL/SQL例子	381
12.7.3  NOT SUBSTITUTABLE
对象	382
12.8  其他有用的对象函数	383
12.8.1  IS OF()	383
12.8.2  TREAT()	387
12.8.3  SYS_TYPEID()	391
12.9  NOT INSTANTIABLE对象
类型	391
12.10  用户自定义的构造函数	393
12.11  重载方法	396
12.12  通用调用	398
12.13  小结	400
第13章  集合	401
13.1  集合简介	401
13.2  创建集合类型	402
13.2.1  创建变长数组类型	402
13.2.2  创建嵌套表类型	403
13.3  使用集合类型定义表列	403

13.3.1  使用变长数组类型定义
表列	403
13.3.2  使用嵌套表类型定义表列	404
13.4　获取集合信息	404
13.4.1  获取变长数组信息	404
13.4.2  获得嵌套表信息	405
13.5  填充集合元素	407
13.5.1  填充变长数组元素	407
13.5.2  填充嵌套表元素	407
13.6  检索集合元素	408
13.6.1  检索变长数组元素	408
13.6.2  检索嵌套表元素	409
13.7  使用TABLE()将集合视为
一系列行	409
13.7.1  将TABLE()用于变长数组	410
13.7.2  将TABLE()用于嵌套表	411
13.8  更改集合元素	411
13.8.1  更改变长数组元素	411
13.8.2  更改嵌套表元素	412
13.9  使用映射方法比较嵌套表的
内容	413
13.10  使用CAST()将集合从一种
类型转换为另一种类型	415
13.10.1  使用CAST()将变长数组
转换为嵌套表	416
13.10.2  使用CAST()将嵌套表转
换为变长数组	416
13.11  在PL/SQL中使用集合	417
13.11.1  操作变长数组	417
13.11.2  操作嵌套表	419
13.11.3  PL/SQL集合方法	421
13.12  多级集合类型	431
13.13  Oracle Database 10g对集合
的增强	433
13.13.1  关联数组	434
13.13.2  更改元素类型的大小	435
13.13.3  增加变长数组的元素
数目	435


13.13.4  在临时表中使用变长
数组	435
13.13.5  为嵌套表的存储表使用
不同的表空间	435
13.13.6  嵌套表对ANSI的支持	436
13.14  小结	444
第14章  大对象	447
14.1  大对象(LOB)简介	448
14.2  示例文件	448
14.3  理解大对象类型	449
14.4  创建包含大对象的表	449
14.5  在SQL中使用大对象	450
14.5.1  使用CLOB和BLOB	450
14.5.2  使用BFILE	452
14.6  在PL/SQL中使用大对象	454
14.6.1  APPEND()	456
14.6.2  CLOSE()	457
14.6.3  COMPARE()	457
14.6.4  COPY()	458
14.6.5  CREATETEMPORARY()	459
14.6.6  ERASE()	460
14.6.7  FILECLOSE()	460
14.6.8  FILECLOSEALL()	461
14.6.9  FILEEXISTS()	461
14.6.10  FILEGETNAME()	462
14.6.11  FILEISOPEN()	462
14.6.12  FILEOPEN()	463
14.6.13  FREETEMPORARY()	463
14.6.14  GETCHUNKSIZE()	464
14.6.15  GET_STORAGE_LIMIT()	464
14.6.16  GETLENGTH()	464
14.6.17  INSTR()	465
14.6.18  ISOPEN()	466
14.6.19  ISTEMPORARY()	467
14.6.20  LOADFROMFILE()	467
14.6.21  LOADBLOBFROMFILE()	468
14.6.22  LOADCLOBFROMFILE()	469
14.6.23  OPEN()	470
14.6.24  READ()	471
14.6.25  SUBSTR()	471
14.6.26  TRIM()	473
14.6.27  WRITE()	473
14.6.28  WRITEAPPEND()	474
14.6.29  PL/SQL示例过程	475
14.7  理解LONG和LONG RAW
类型	492
14.7.1  示例表	492
14.7.2  向LONG和LONG RAW
列添加数据	492
14.7.3  将LONG和LONG RAW
列转换为LOB	493
14.8  Oracle Database 10g对大对象
的增强	494
14.8.1  CLOB和NCLOB对象之间
的隐式转换	494
14.8.2  在触发器中使用LOB时
:new属性的用法	495
14.9  Oracle Database 11g对大对象
的增强	495
14.9.1  加密LOB数据	496
14.9.2  压缩LOB数据	499
14.9.3  删除LOB重复数据	499
14.10  小结	500
第15章  在Java程序中运行SQL	501
15.1  准备工作	502
15.2  配置计算机	502
15.2.1  设置ORACLE_HOME
环境变量	502
15.2.2  设置JAVA_HOME环境
变量	503
15.2.3  设置PATH环境变量	503
15.2.4  设置CLASSPATH环境
变量	504
15.2.5  设置LD_LIBRARY_PATH
环境变量	504
15.3  Oracle JDBC驱动程序	505
15.3.1  Thin驱动程序	505
15.3.2  OCI驱动程序	505
15.3.3  服务器端内部驱动程序	505
15.3.4  服务器端Thin驱动程序	505
15.4  导入JDBC包	506
15.5  注册Oracle JDBC驱动程序	506
15.6  打开数据库连接	506
15.6.1  使用getConnection()方法
连接数据库	507
15.6.2  数据库URL	507
15.6.3  使用Oracle数据源连接
数据库	508
15.7  创建JDBC Statement对象	511
15.8  从数据库中检索行	511
15.8.1  步骤1：创建和填充
ResultSet对象	511
15.8.2  步骤2：从ResultSet对象
中读取列值	512
15.8.3  步骤3：关闭ResultSet
对象	514
15.9  向数据库中添加行	514
15.10  更改数据库的行	515
15.11  删除数据库的行	516
15.12  处理数字	516
15.13  处理数据库Null值	517
15.14  控制数据库事务	519
15.15  执行DDL语句	519
15.16  处理异常	520
15.17  关闭JDBC对象	521
15.18  示例程序：
BasicExample1.java	522
15.18.1  编译BasicExample1	527
15.18.2  运行BasicExample1	527
15.19  预备SQL语句	529
15.20  示例程序：
BasicExample2.java	531
15.21  Oracle JDBC扩展	534
15.21.1  oracle.sql包	534
15.21.2  oracle.jdbc包	537
15.21.3  示例程序：
BasicExample3.java	540
15.22  小结	543
第16章  SQL优化	545
16.1  SQL优化简介	545
16.2  使用WHERE子句过滤行	546
16.3  使用表连接而不是多个查询	546
16.4  执行连接时使用完全限定的
列引用	547
16.5  使用CASE表达式而不是
多个查询	548
16.6  添加表索引	549
16.7  使用WHERE而不是
HAVING	550
16.8  使用UNION ALL而不是
UNION	550
16.9  使用EXISTS而不是IN	552
16.10  使用EXISTS而不是
DISTINCT	552
16.11  使用GROUPING SETS而
不是CUBE	553
16.12  使用绑定变量	553
16.12.1  不相同的SQL语句	554
16.12.2  使用绑定变量定义相同
SQL语句	554
16.12.3  列出和输出绑定变量	555
16.12.4  使用绑定变量存储PL/SQL
函数的返回值	555
16.12.5  使用绑定变量存储
REFCURSOR的行	556
16.13  比较执行查询的成本	556
16.13.1  检查执行计划	557
16.13.2  比较执行计划	562
16.14  为优化器传递提示	563
16.15  其他优化工具	564
16.15.1  Oracle Enterprise Manager 
Diagnostics Pack	565
16.15.2  Automatic Database 
Diagnostic Monitor	565
16.16  小结	566
第17章  XML和Oracle数据库	567
17.1  XML简介	567
17.2  从关系数据生成XML	568
17.2.1  XMLELEMENT()	568
17.2.2  XMLATTRIBUTES()	571
17.2.3  XMLFOREST()	571
17.2.4  XMLAGG()	573
17.2.5  XMLCOLATTVAL()	575
17.2.6  XMLCONCAT()	576
17.2.7  XMLPARSE()	576
17.2.8  XMLPI()	577
17.2.9  XMLCOMMENT()	577
17.2.10  XMLSEQUENCE()	578
17.2.11  XMLSERIALIZE()	579
17.2.12  PL/SQL范例：将XML
数据写入文件	579
17.2.13  XMLQUERY()	581
17.3  将XML保存到数据库中	585
17.3.1  范例XML文件	585
17.3.2  创建范例XML模式	586
17.3.3  从范例XML模式检索
信息	588
17.3.4  更新范例XML模式中的
信息	592
17.4  小结	595
附录A  Oracle数据类型	597
