
出版者的话
译者序
前言
第1章 引论
　1.1 语言处理器
　1.2 一个编译器的结构
　　1.2.1 词法分析
　　1.2.2 语法分析
　　1.2.3 语义分析
　　1.2.4 中间代码生成
　　1.2.5 代码优化
　　1.2.6 代码生成
　　1.2.7 符号表管理
　　1.2.8 将多个步骤组合成趟
　　1.2.9 编译器构造工具
　1.3 程序设计语言的发展历程
　　1.3.1 走向高级程序设计语言
　　1.3.2 对编译器的影响
　　1.3.3 1.3节的练习
　1.4 构建一个编译器的相关科学
　　1.4.1 编译器设计和实现中的建模
　　1.4.2 代码优化的科学
　1.5 编译技术的应用
　　1.5.1 高级程序设计语言的实现
　　1.5.2 针对计算机体系结构的优化
　　1.5.3 新计算机体系结构的设计
　　1.5.4 程序翻译
　　1.5.5 软件生产率工具
　1.6 程序设计语言基础
　　1.6.1 静态和动态的区别
　　1.6.2 环境与状态
　　1.6.3 静态作用域和块结构
　　1.6.4 显式访问控制
　　1.6.5 动态作用域
　　1.6.6 参数传递机制
　　1.6.7 别名
　　1.6.8 1.6节的练习
　1.7 第1章的总结
　1.8 第1章的参考书目
第2章 一个简单的语法制导翻译器
　2.1 引言
　2.2 语法定义
　　2.2.1 文法定义
　　2.2.2 推导
　　2.2.3 语法分析树
　　2.2.4 二义性
　　2.2.5 运算符的结合性
　　2.2.6 运算符的优先级
　　2.2.7 2.2节的练习
　2.3 语法制导翻译
　　2.3.1 后缀表示
　　2.3.2 综合属性
　　2.3.3 简单语法制导定义
　　2.3.4 树的遍历
　　2.3.5 翻译方案
　　2.3.6 2.3节的练习
　2.4 语法分析
　　2.4.1 自顶向下分析方法
　　2.4.2 预测分析法
　　2.4.3 何时使用产生式
　　2.4.4 设计一个预测语法分析器
　　2.4.5 左递归
　　2.4.6 2.4节的练习
　2.5 简单表达式的翻译器
　　2.5.1抽象语法和具体语法
　　2.5.2调整翻译方案
　　2.5.3非终结符号的过程
　　2.5.4 翻译器的简化
　　2.5.5 完整的程序
　2.6 词法分析
　　2.6.1 剔除空白和注释
　　2.6.2 预读
　　2.6.3 常量
　　2.6.4 识别关键字和标识符
　　2.6.5 词法分析器
　　2.6.6 2.6节的练习
　2.7 符号表
　　2.7.1 为每个作用域设置一个符号表
　　2.7.2 符号表的使用
　2.8 中间代码生成
　　2.8.1 两种中间表示形式
　　2.8.2 语法树的构造
　　2.8.4 三地址码
　　2.8.5 2.8节的练习
　2.9 第2章的总结
第3章 词法分析
　3.1 词法分析器的作用
　　3.1.1 词法分析及解析
　　3.1.2 词法单元、模式、词素
　　3.1.3 词法单元的属性
　　3.1.4 词法错误
　　3.1.5 3.1节的练习
　3.2 输入缓冲
　　3.2.1 缓冲区对
　　3.2.2 哨兵标记
　3.3 词法单元的规约
　3.3.1 串和语言
　　3.3.2 语言上的运算
　　3.3.3 正则表达式
　　3.3.4 正则定义
　　3.3.5 正则表达式的扩展
　　3.3.6 3.3节的练习
　3.4 词法单元的识别
　　3.4.1 状态转换图
　　3.4.2 保留字和标识符的识别
　　3.4.3 完成我们的连续性例子
　　3.4.4 基于状态转换图的词法分析器的体系结构
　　3.4.5 3.4节的练习
　3.5 词法分析器生成工具Lex
　　3.5.1 Lex的使用
　　3.5.2 Lex程序的结构
　　3.5.3 Lex中的冲突解决
　　3.5.4 向前看运算符
　　3.5.5 3.5节练习
　3.6 有穷自动机
　　3.6.1 不确定的有穷自动机
　　3.6.2 转换表
　　3.6.3 NFA接受输入字符串
　　3.6.4 确定的有穷自动机
　　3.6.5 3.6节的练习
　3.7 从正则表达式到自动机
　　3.7.1 从NFA到DFA的转换
　　3.7.2 NFA的模拟
　　3.7.3 NFA模拟效率
　　3.7.4 从正则表达式构造NFA
　　3.7.5 字符串处理算法的效率
　　3.7.6 3.7节的练习
　3.8 词法分析器生成工具的设计
　　3.8.1 被生成的词法分析器的结构
　　3.8.2 基于NFA的模式匹配
　　3.8.3 词法分析器使用的DFA
　　3.8.4 实现向前看运算符
　　3.8.5 3.8的练习
　3.9 基于DFA的模式匹配器的优化
　　3.9.1 NFA的重要状态
　　3.9.2 根据抽象语法树计算得到的函数
　　3.9.3 计算nullable、firstpos及lastpos
　　3.9.4 计算followpos
　　3.9.5 根据正则表达式构建DFA
　　3.9.6 最小化一个DFA的状态数
　　3.9.7 词法分析器的状态最小化
　　3.9.8 在DFA模拟中用时间换取空间
　　3.9.9 3.9节的练习
　　3.9.10 第3章的总结
　3.11 第3章参考文献
第4章 语法分析
　4.1 引论
　　4.1.1 语法分析器的角色
　　4.1.2 代表性的文法
　　4.1.3 语法错误的处理
　　4.1.4 错误恢复策略
　4.2 上下文无关文法
　　4.2.1 上下文无关文法的正式定义
　　4.2.2 符号表示的惯例
　 4.2.3 推导
4.2.4 语法分析树和推导
　 4.2.5 二义性
　　4.2.6 验证文法生成的语言
　　4.2.7上下文无关文法和正则表达式
　　4.2.8 4.2节的练习
　4.3 设计文法
　　4.3.1 词法分析和语法分析
　　4.3.2 消除二义性
　　4.3.3 左递归的消除
　　4.3.4 提取左公因子
　　4.3.5 非上下文无关的语言构造
　　4.3.6 4.3节的练习
　4.4 自顶向下的语法分析
　　4.4.1 递归下降的语法分析
　　4.4.2 FIRST和FOLLOW
　　4.4.3 LL(1)文法
　　4.4.4 非递归的预测分析
　　4.4.5 预测分析中的错误恢复
　　4.4.6 4.4节的练习
　4.5 自底向上的语法分析
　　4.5.1 归约
　　4.5.2 句柄剪枝
　　4.5.3 移入-归约语法分析技术
　　4.5.4 移入-归约语法分析中的冲突
　　4.5.5 4.5节的练习
　4.6 LR语法分析技术介绍：简单LR技术
　　4.6.1 为什么使用LR语法分析器？
　　4.6.2 项和LR(0)自动机
　　4.6.3 LR-语法分析算法
　　4.6.4 构造SLR-分析表
　　4.6.5 可行前缀
　　4.6.6 4.6节的练习
　4.7 更强大的LR语法分析器
　　4.7.1 规范LR(1)项
　　4.7.2 构造LR(1)项集
　　4.7.3 规范LR(1)分析表
　　4.7.4 构造LALR语法分析表
　　4.7.5 LALR语法分析表的高效构造方法
　　4.7.6 LR语法分析表的压缩
　　4.7.7 4.7节的练习
　4.8 使用二义性文法
　　4.8.1 用优先级和结合性解决冲突
　　4.8.2 “悬空-else”二义性
　　4.8.3 LR语法分析中的错误恢复
　　4.8.4 4.8节的练习
　4.9 语法分析器的生成工具
　　4.9.1 语法分析器的生成工具Yacc
　　4.9.2 使用Yacc处理二义性文法
　　4.9.3 用Lex创建Yacc的词法分析器
　　4.9.4 Yacc中的错误恢复
　　4.9.5 4.9节的练习
　4.10：第4章的小结
　4.11 第4章的参考文献
第5章 语法制导的翻译
　5.1 语法制导定义
　　5.1.1 继承属性和综合属性
　　5.1.2 在一棵语法分析树的结点上对一个SDD求值
　　5.1.3 5.1节的练习
　5.2 SDD的求值顺序
　　5.2.1 依赖图
　　5.2.2 属性求值的顺序
　　5.2.3 S-属性定义
　　5.2.4 L-属性定义
　　5.2.5 具有受控副作用的语义规则
　　5.2.6 5.2节的练习
　5.3 语法制导翻译的应用
　　5.3.1 抽象语法树的构造
　　5.3.2 类型的结构
　　5.3.3 5.3节的练习
　5.4 语法制导的翻译方案
　　5.4.1 后缀翻译方案
　　5.4.2 后缀SDT的语法分析栈实现
　　5.4.3 产生式内部带有语义动作的SDT
　　5.4.4 从SDT中消除左递归
　　5.4.5 L-属性定义的SDT
　　5.4.6 5.4节的练习
　5.5 实现L-属性的SDD
　　5.5.1 在递归下降语法分析过程中进行翻译
　　5.5.2 边扫描边生成代码
　　5.5.3 L-属性的SDD和LL语法分析
　　5.5.4 L-属性的SDD的自底向上语法分析
　　5.5.5 5.5节的练习 　
　5.6 第5章的总结
　5.7 第5章的参考文献
第6章 中间代码生成
第7章 运行时刻环境
第7章 总结
第8章 代码生成
第9章 机器无关优化
第10章 指令级并行
第11章 并行性和局部性的优化
第12章 过程间分析
