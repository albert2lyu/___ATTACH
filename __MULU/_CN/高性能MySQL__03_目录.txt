
目录
推荐序  xxiii
前言  xxv
第1 章 MySQL 架构与历史  1
1.1 MySQL 逻辑架构  1
1.1.1 连接管理与安全性  2
1.1.2 优化与执行  3
1.2 并发控制  3
1.2.1 读写锁  4
1.2.2 锁粒度  4
1.3 事务  6
1.3.1 隔离级别  8
1.3.2 死锁  9
1.3.3 事务日志  10
1.3.4 MySQL 中的事务  10
1.4 多版本并发控制  12
1.5 MySQL 的存储引擎 13
1.5.1 InnoDB 存储引擎  16
1.5.2 MyISAM 存储引擎  17
1.5.3 MySQL 内建的其他存储引擎  19
1.5.4 第三方存储引擎  22
1.5.5 选择合适的引擎  24
1.5.6 转换表的引擎 27
1.6 MySQL 时间线（Timeline）  29
1.7 MySQL 的开发模式 32
1.8 总结  33
第2 章 MySQL 基准测试   35
2.1 为什么需要基准测试  35
2.2 基准测试的策略  37
2.2.1 测试何种指标 38
2.3 基准测试方法  40
2.3.1 设计和规划基准测试  41
2.3.2 基准测试应该运行多长时间  42
2.3.3 获取系统性能和状态  43
2.3.4 获得准确的测试结果  44
2.3.5 运行基准测试并分析结果  46
2.3.6 绘图的重要性 47
2.4 基准测试工具  49
2.4.1 集成式测试工具  49
2.4.2 单组件式测试工具  50
2.5 基准测试案例  52
2.5.1 http_load  53
2.5.2 MySQL 基准测试套件 .54
2.5.3 sysbench  55
2.5.4 数据库测试套件中的dbt2 TPC-C 测试  60
2.5.5 Percona 的TPCC-MySQL 测试工具  63
2.6 总结  65
第3 章 服务器性能剖析   67
3.1 性能优化简介  67
3.1.1 通过性能剖析进行优化  69
3.1.2 理解性能剖析 71
3.2 对应用程序进行性能剖析  72
3.2.1 测量PHP 应用程序  74
3.3 剖析MySQL 查询  77
3.3.1 剖析服务器负载  77
3.3.2 剖析单条查询 81
3.3.3 使用性能剖析 87
3.4 诊断间歇性问题  88
3.4.1 单条查询问题还是服务器问题  89
3.4.2 捕获诊断数据 93
3.4.3 一个诊断案例 98
3.5 其他剖析工具   106
3.5.1 使用USER_STATISTICS 表   106
3.5.2 使用strace   107
3.6 总结   108
第4 章 Schema 与数据类型优化   111
4.1 选择优化的数据类型   111
4.1.1 整数类型   113
4.1.2 实数类型   113
4.1.3 字符串类型   114
4.1.4 日期和时间类型   121
4.1.5 位数据类型   123
4.1.6 选择标识符（identifier）   125
4.1.7 特殊类型数据   127
4.2 MySQL schema 设计中的陷阱   127
4.3 范式和反范式   129
4.3.1 范式的优点和缺点   130
4.3.2 反范式的优点和缺点 . 130
4.3.3 混用范式化和反范式化   131
4.4 缓存表和汇总表   132
4.4.1 物化视图   134
4.4.2 计数器表   135
4.5 加快ALTER TABLE 操作的速度   136
4.5.1 只修改.frm 文件   137
4.5.2 快速创建MyISAM 索引   139
4.6 总结   140
第5 章 创建高性能的索引   141
5.1 索引基础   141
5.1.1 索引的类型   142
5.2 索引的优点   152
5.3 高性能的索引策略  153
5.3.1 独立的列   153
5.3.2 前缀索引和索引选择性   153
5.3.3 多列索引   157
5.3.4 选择合适的索引列顺序   159
5.3.5 聚簇索引   162
5.3.6 覆盖索引   171
5.3.7 使用索引扫描来做排序   175
5.3.8 压缩（前缀压缩）索引   177
5.3.9 冗余和重复索引   178
5.3.10 未使用的索引   181
5.3.11 索引和锁   181
5.4 索引案例学习   183
5.4.1 支持多种过滤条件   183
5.4.2 避免多个范围条件   185
5.4.3 优化排序   186
5.5 维护索引和表   187
5.5.1 找到并修复损坏的表 . 187
5.5.2 更新索引统计信息   188
5.5.3 减少索引和数据的碎片   190
5.6 总结   192
第6 章 查询性能优化   195
6.1 为什么查询速度会慢   195
6.2 慢查询基础：优化数据访问   196
6.2.1 是否向服务器请求了不需要的数据   196
6.2.2 MySQL 是否在扫描额外的记录   198
6.3 重构查询的方式   201
6.3.1 一个复杂查询还是多个简单查询   201
6.3.2 切分查询   202
6.3.3 分解关联查询   203
6.4 查询执行的基础   204
6.4.1 MySQL 客户端/ 服务器通信协议   205
6.4.2 查询缓存   208
6.4.3 查询优化处理   208
6.4.4 查询执行引擎   222
6.4.5 返回结果给客户端   223
6.5 MySQL 查询优化器的局限性   223
6.5.1 关联子查询   223
6.5.2 UNION 的限制   228
6.5.3 索引合并优化   228
6.5.4 等值传递   229
6.5.5 并行执行   229
6.5.6 哈希关联   229
6.5.7 松散索引扫描   229
6.5.8 最大值和最小值优化 . 231
6.5.9 在同一个表上查询和更新   232
6.6 查询优化器的提示（hint）   232
6.7 优化特定类型的查询   236
6.7.1 优化COUNT() 查询   236
6.7.2 优化关联查询   239
6.7.3 优化子查询   239
6.7.4 优化GROUP BY 和DISTINCT   239
6.7.5 优化LIMIT 分页   241
6.7.6 优化SQL_CALC_FOUND_ROWS   243
6.7.7 优化UNION 查询  243
6.7.8 静态查询分析   244
6.7.9 使用用户自定义变量 . 244
6.8 案例学习   251
6.8.1 使用MySQL 构建一个队列表   251
6.8.2 计算两点之间的距离 . 254
6.8.3 使用用户自定义函数 . 257
6.9 总结   258
第7 章 MySQL 高级特性  259
7.1 分区表   259
7.1.1 分区表的原理   260
7.1.2 分区表的类型   261
7.1.3 如何使用分区表   262
7.1.4 什么情况下会出问题 . 263
7.1.5 查询优化   266
7.1.6 合并表   267
7.2 视图   270
7.2.1 可更新视图   272
7.2.2 视图对性能的影响   273
7.2.3 视图的限制   274
7.3 外键约束   275
7.4 在MySQL 内部存储代码   276
7.4.1 存储过程和函数   278
7.4.2 触发器   279
7.4.3 事件   281
7.4.4 在存储程序中保留注释   283
7.5 游标   283
7.6 绑定变量   284
7.6.1 绑定变量的优化   286
7.6.2 SQL 接口的绑定变量  286
7.6.3 绑定变量的限制   288
7.7 用户自定义函数   289
7.8 插件   290
7.9 字符集和校对   291
7.9.1 MySQL 如何使用字符集   292
7.9.2 选择字符集和校对规则   295
7.9.3 字符集和校对规则如何影响查询   296
7.10 全文索引   299
7.10.1 自然语言的全文索引   300
7.10.2 布尔全文索引   302
7.10.3 MySQL5.1 中全文索引的变化   303
7.10.4 全文索引的限制和替代方案   304
7.10.5 全文索引的配置和优化   306
7.11 分布式（XA）事务   307
7.11.1 内部XA 事务   307
7.11.2 外部XA 事务   308
7.12 查询缓存   309
7.12.1 MySQL 如何判断缓存命中   309
7.12.2 查询缓存如何使用内存   311
7.12.3 什么情况下查询缓存能发挥作用   313
7.12.4 如何配置和维护查询缓存   316
7.12.5 InnoDB 和查询缓存 . 319
7.12.6 通用查询缓存优化   320
7.12.7 查询缓存的替代方案   321
7.13 总结   321
第8 章 优化服务器设置   325
8.1 MySQL 配置的工作原理   326
8.1.1 语法、作用域和动态性   327
8.1.2 设置变量的副作用   328
8.1.3 入门   331
8.1.4 通过基准测试迭代优化   332
8.2 什么不该做   333
8.3 创建MySQL 配置文件   335
8.3.1 检查MySQL 服务器状态变量   339
8.4 配置内存使用   340
8.4.1 MySQL 可以使用多少内存？   340
8.4.2 每个连接需要的内存 . 341
8.4.3 为操作系统保留内存 . 341
8.4.4 为缓存分配内存   342
8.4.5 InnoDB 缓冲池（Buffer Pool）   342
8.4.6 MyISAM 键缓存（Key Caches）   344
8.4.7 线程缓存   346
8.4.8 表缓存（Table Cache）   347
8.4.9 InnoDB 数据字典（Data Dictionary）   348
8.5 配置MySQL 的I/O 行为   349
8.5.1 InnoDB I/O 配置   349
8.5.2 MyISAM 的I/O 配置 . 361
8.6 配置MySQL 并发 . 363
8.6.1 InnoDB 并发配置   364
8.6.2 MyISAM 并发配置   365
8.7 基于工作负载的配置   366
8.7.1 优化BLOB 和TEXT 的场景   367
8.7.2 优化排序（Filesorts）. 368
8.8 完成基本配置   369
8.9 安全和稳定的设置  371
8.10 高级InnoDB 设置   374
8.11 总结   376
第9 章 操作系统和硬件优化   377
9.1 什么限制了MySQL 的性能  377
9.2 如何为MySQL 选择CPU   378
9.2.1 哪个更好：更快的CPU 还是更多的CPU  378
9.2.2 CPU 架构   380
9.2.3 扩展到多个CPU 和核心   381
9.3 平衡内存和磁盘资源   382
9.3.1 随机I/O 和顺序I/O   383
9.3.2 缓存，读和写   384
9.3.3 工作集是什么   385
9.3.4 找到有效的内存/ 磁盘比例   386
9.3.5 选择硬盘   387
9.4 固态存储   389
9.4.1 闪存概述   390
9.4.2 闪存技术   391
9.4.3 闪存的基准测试   392
9.4.4 固态硬盘驱动器（SSD）   393
9.4.5 PCIe 存储设备   395
9.4.6 其他类型的固态存储 . 396
9.4.7 什么时候应该使用闪存   396
9.4.8 使用Flashcache   397
9.4.9 优化固态存储上的MySQL   399
9.5 为备库选择硬件   402
9.6 RAID 性能优化   403
9.6.1 RAID 的故障转移、恢复和镜像   405
9.6.2 平衡硬件RAID 和软件RAID   406
9.6.3 RAID 配置和缓存   407
9.7 SAN 和NAS   410
9.7.1 SAN 基准测试   411
9.7.2 使用基于NFS 或SMB 的SAN   412
9.7.3 MySQL 在SAN 上的性能   412
9.7.4 应该用SAN 吗   413
9.8 使用多磁盘卷   414
9.9 网络配置   416
9.10 选择操作系统   418
9.11 选择文件系统   419
9.12 选择磁盘队列调度策略   421
9.13 线程   422
9.14 内存交换区   422
9.15 操作系统状态   424
9.15.1 如何阅读vmstat 的输出   425
9.15.2 如何阅读iostat 的输出   426
9.15.3 其他有用的工具   428
9.15.4 CPU 密集型的机器   428
9.15.5 I/O 密集型的机器   429
9.15.6 发生内存交换的机器   430
9.15.7 空闲的机器  430
9.16 总结   431
第10 章 复制   433
10.1 复制概述   433
10.1.1 复制解决的问题   434
10.1.2 复制如何工作   435
10.2 配置复制   436
10.2.1 创建复制账号   437
10.2.2 配置主库和备库   437
10.2.3 启动复制   439
10.2.4 从另一个服务器开始复制   441
10.2.5 推荐的复制配置   443
10.3 复制的原理   445
10.3.1 基于语句的复制   445
10.3.2 基于行的复制   446
10.3.3 基于行或基于语句：哪种更优   446
10.3.4 复制文件   448
10.3.5 发送复制事件到其他备库   449
10.3.6 复制过滤器  450
10.4 复制拓扑   452
10.4.1 一主库多备库   452
10.4.2 主动- 主动模式下的主- 主复制  453
10.4.3 主动- 被动模式下的主- 主复制  455
10.4.4 拥有备库的主- 主结构   456
10.4.5 环形复制   457
10.4.6 主库、分发主库以及备库   458
10.4.7 树或金字塔形   460
10.4.8 定制的复制方案   460
10.5 复制和容量规划   465
10.5.1 为什么复制无法扩展写操作   466
10.5.2 备库什么时候开始延迟   466
10.5.3 规划冗余容量   467
10.6 复制管理和维护   468
10.6.1 监控复制   468
10.6.2 测量备库延迟   469
10.6.3 确定主备是否一致   469
10.6.4 从主库重新同步备库   470
10.6.5 改变主库   471
10.6.6 在一个主- 主配置中交换角色   476
10.7 复制的问题和解决方案   477
10.7.1 数据损坏或丢失的错误   477
10.7.2 使用非事务型表   480
10.7.3 混合事务型和非事务型表   480
10.7.4 不确定语句  481
10.7.5 主库和备库使用不同的存储引擎   481
10.7.6 备库发生数据改变   481
10.7.7 不唯一的服务器ID . 482
10.7.8 未定义的服务器ID . 482
10.7.9 对未复制数据的依赖性   482
10.7.10 丢失的临时表   483
10.7.11 不复制所有的更新 . 484
10.7.12 InnoDB 加锁读引起的锁争用   484
10.7.13 在主- 主复制结构中写入两台主库   486
10.7.14 过大的复制延迟   488
10.7.15 来自主库的过大的包   491
10.7.16 受限制的复制带宽 . 491
10.7.17 磁盘空间不足   492
10.7.18 复制的局限性   492
10.8 复制有多快   492
10.9 MySQL 复制的高级特性   494
10.10 其他复制技术   496
10.11 总结   498
第11 章 可扩展的MySQL   501
11.1 什么是可扩展性   501
11.1.1 正式的可扩展性定义   503
11.2 扩展MySQL   507
11.2.1 规划可扩展性   507
11.2.2 为扩展赢得时间   508
11.2.3 向上扩展   509
11.2.4 向外扩展   510
11.2.5 通过多实例扩展   525
11.2.6 通过集群扩展   526
11.2.7 向内扩展   530
11.3 负载均衡   532
11.3.1 直接连接   534
11.3.2 引入中间件  537
11.3.3 一主多备间的负载均衡   540
11.4 总结   541
第12 章 高可用性   543
12.1 什么是高可用性   543
12.2 导致宕机的原因   544
12.3 如何实现高可用性   545
12.3.1 提升平均失效时间（MTBF）   545
12.3.2 降低平均恢复时间（MTTR）   547
12.4 避免单点失效   548
12.4.1 共享存储或磁盘复制   549
12.4.2 MySQL 同步复制   551
12.4.3 基于复制的冗余   555
12.5 故障转移和故障恢复   556
12.5.1 提升备库或切换角色   558
12.5.2 虚拟IP 地址或IP 接管   558
12.5.3 中间件解决方案   559
12.5.4 在应用中处理故障转移   560
12.6 总结   560
第13 章 云端的MySQL   563
13.1 云的优点、缺点和相关误解   564
13.2 MySQL 在云端的经济价值   566
13.3 云中的MySQL 的可扩展性和高可用性   567
13.4 四种基础资源   568
13.5 MySQL 在云主机上的性能   569
13.5.1 在云端的MySQL 基准测试   571
13.6 MySQL 数据库即服务（DBaaS）   573
13.6.1 Amazon RDS   573
13.6.2 其他DBaaS 解决方案   574
13.7 总结   575
第14 章 应用层优化   577
14.1 常见问题   577
14.2 Web 服务器问题   579
14.2.1 寻找最优并发度   581
14.3 缓存   582
14.3.1 应用层以下的缓存   583
14.3.2 应用层缓存  584
14.3.3 缓存控制策略   586
14.3.4 缓存对象分层   587
14.3.5 预生成内容  588
14.3.6 作为基础组件的缓存   589
14.3.7 使用HandlerSocket 和memcached   589
14.4 拓展MySQL  590
14.5 MySQL 的替代品  590
14.6 总结   591
第15 章 备份与恢复   593
15.1 为什么要备份   594
15.2 定义恢复需求   595
15.3 设计MySQL 备份方案   596
15.3.1 在线备份还是离线备份   597
15.3.2 逻辑备份还是物理备份   598
15.3.3 备份什么   601
15.3.4 存储引擎和一致性   603
15.4 管理和备份二进制日志   605
15.4.1 二进制日志格式   606
15.4.2 安全地清除老的二进制日志   607
15.5 备份数据   607
15.5.1 生成逻辑备份   607
15.5.2 文件系统快照   610
15.6 从备份中恢复   617
15.6.1 恢复物理备份   618
15.6.2 还原逻辑备份   619
15.6.3 基于时间点的恢复   622
15.6.4 更高级的恢复技术   624
15.6.5 InnoDB 崩溃恢复   625
15.7 备份和恢复工具   628
15.7.1 MySQL Enterprise Backup   628
15.7.2 Percona XtraBackup . 628
15.7.3 mylvmbackup   629
15.7.4 Zmanda Recovery Manager   629
15.7.5 mydumper   629
15.7.6 mysqldump. 629
15.8 备份脚本化   631
15.9 总结   633
第16 章 MySQL 用户工具   635
16.1 接口工具   635
16.2 命令行工具集   636
16.3 SQL 实用集   637
16.4 监测工具   637
16.4.1 开源的监控工具   638
16.4.2 商业监控系统   640
16.4.3 Innotop 的命令行监控   642
16.5 总结   646
附录A MySQL 分支与变种   649
附录B MySQL 服务器状态   655
附录C 大文件传输   683
附录D EXPLAIN   687
附录E 锁的调试   703
附录F 在MySQL 上使用Sphinx   713
索引   739
