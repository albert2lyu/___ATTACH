
序
前　言
第1章　SQL编程/1
1.1　MySQL数据库/2
1.1.1　MySQL数据库历史/2
1.1.2　MySQL数据库的分支版本/4
1.2　SQL编程/5
1.3　数据库的应用类型/7
1.3.1　OLTP/7
1.3.2　OLAP/8
1.3.3　OLTP与OLAP的比较/9
1.3.4　MySQL存储引擎及其面向的数据库应用/10
1.4　图形化的SQL查询分析器/12
1.4.1　MySQL Workbench/12
1.4.2　Toad for MySQL/12
1.4.3　iMySQL-Front/13
1.5　小结/15
第2章　数据类型/16
2.1　类型属性/17
2.1.1　UNSIGNED/17
2.1.2　ZEROFILL/20
2.2　SQL_MODE设置/21
2.3　日期和时间类型/26
2.3.1　DATETIME和 DATE/26
2.3.2　TIMESTAMP/28
2.3.3　YEAR和TIME/30
2.3.4　与日期和时间相关的函数/31
2.4　关于日期的经典SQL编程问题/34
2.4.1　生日问题/34
2.4.2　重叠问题/37
2.4.3　星期数的问题/48
2.5　数字类型/53
2.5.1　整型/53
2.5.2　浮点型（非精确类型）/54
2.5.3　高精度类型/54
2.5.4　位类型/55
2.6　关于数字的经典SQL编程问题/56
2.6.1　数字辅助表/56
2.6.2　连续范围问题/58
2.7　字符类型/60
2.7.1　字符集/60
2.7.2　排序规则/64
2.7.3　CHAR和VARCHAR/68
2.7.4　BINARY和VARBINARY/70
2.7.5　BLOB和TEXT/72
2.7.6　ENUM和SET类型/73
2.8　小结/75
第3章　查询处理/76
3.1　逻辑查询处理/77
3.1.1　执行笛卡儿积/79
3.1.2　应用ON过滤器/80
3.1.3　添加外部行/83
3.1.4　应用WHERE过滤器/84
3.1.5　分组/85
3.1.6　应用ROLLUP或CUBE/86
3.1.7　应用HAVING过滤器/86
3.1.8　处理SELECT列表/87
3.1.9　应用DISTINCT子句/87
3.1.10　应用ORDER BY子句/88
3.1.11　LIMIT子句/92
3.2　物理查询处理/93
3.3　小结/95
第4章　子查询/96
4.1　子查询概述/97
4.1.1　子查询的优点和限制/97
4.1.2　使用子查询进行比较/97
4.1.3　使用ANY、IN和SOME进行子查询/98
4.1.4　使用ALL进行子查询/99
4.2　独立子查询/99
4.3　相关子查询/105
4.4　EXISTS谓词/109
4.4.1　EXISTS /109
4.4.2　NOT EXISTS/111
4.5　派生表/113
4.6　子查询可以解决的经典问题/114
4.6.1　行号/114
4.6.2　分区/118
4.6.3　最小缺失值问题/121
4.6.4　缺失范围和连续范围/122
4.7　MariaDB对SEMI JOIN的优化/126
4.7.1　概述/126
4.7.2　Table Pullout优化/127
4.7.3　Duplicate Weedout 优化/128
4.7.4　Materialization优化/129
4.8　小结/130
第5章　联接与集合操作/132
5.1　联接查询/133
5.1.1　新旧查询语法/133
5.1.2　CROSS JOIN/134
5.1.3　INNER JOIN/137
5.1.4　OUTER JOIN/138
5.1.5　NATURAL JOIN/141
5.1.6　STRAIGHT_JOIN/141
5.2　其他联接分类/142
5.2.1　SELF JOIN/143
5.2.2　NONEQUI JOIN/144
5.2.3　SEMI JOIN和ANTI SEMI JOIN/145
5.3　多表联接/146
5.4　滑动订单问题/148
5.5　联接算法/150
5.5.1　Simple Nested-Loops Join算法/150
5.5.2　Block Nested-Loops Join算法/155
5.5.3　Batched Key Access Join算法/158
5.5.4　Classic Hash Join算法/161
5.6　集合操作/163
5.6.1　集合操作的概述/163
5.6.2　UNION DISTINCT和UNION ALL/165
5.6.3　EXCEPT/167
5.6.4　INTERSECT/170
5.7　小结/171
第6章　聚合和旋转操作/172
6.1　聚合 /173
6.1.1　聚合函数/173
6.1.2　聚合的算法/174
6.2　附加属性聚合/176
6.3　连续聚合/178
6.3.1　累积聚合/179
6.3.2　滑动聚合/183
6.3.3　年初至今聚合/184
6.4　Pivoting/185
6.4.1　开放架构/185
6.4.2　关系除法/187
6.4.3　格式化聚合数据/189
6.5　Unpivoting/191
6.6　CUBE 和 ROLLUP/193
6.6.1　ROLLUP/193
6.6.2　CUBE/196
6.7　小结/197
第7章　游标/198
7.1　面向集合与面向过程的开发/199
7.2　游标的使用/199
7.3　游标的开销/200
7.4　使用游标解决问题/202
7.4.1　游标的性能分析/202
7.4.2　连续聚合/203
7.4.3　最大会话数/206
7.5　小结/210
第8章　事务编程/211
8.1　事务概述/212
8.2　事务的分类/214
8.3　事务控制语句/219
8.4　隐式提交的SQL语句/224
8.5　事务的隔离级别/225
8.6　分布式事务编程/229
8.7　不好的事务编程习惯/234
8.7.1　在循环中提交/234
8.7.2　使用自动提交/236
8.7.3　使用自动回滚/236
8.8　长事务/239
8.9　小结/240
第9章　索引/242
9.1　缓冲池、顺序读取与随机读取/243
9.2　数据结构与算法/246
9.2.1　二分查找法/246
9.2.2　二叉查找树和平衡二叉树/247
9.3　B+树/249
9.3.1　B+树的插入操作/250
9.3.2　B+树的删除操作/252
9.4　B+树索引/253
9.4.1　InnoDB B+树索引/254
9.4.2　MyISAM B+树索引/256
9.5　Cardinality/256
9.5.1　什么是Cardinality/256
9.5.2　InnoDB存储引擎怎样统计Cardinality/257
9.6　B+树索引的使用/259
9.6.1　不同应用中B+树索引的使用/259
9.6.2　联合索引/260
9.6.3　覆盖索引/262
9.6.4　优化器选择不使用索引的情况/263
9.6.5　INDEX HINT/265
9.7　Multi-Range Read/267
9.8　Index Condition Pushdown/269
9.9　T树索引/271
9.9.1　T树概述/271
9.9.2　T树的查找、插入和删除操作/272
9.9.3　T树的旋转/273
9.10　哈希索引/276
9.10.1　散列表/276
9.10.2　InnoDB存储引擎中的散列算法/278
9.10.3　自适应哈希索引/278
9.11　小结/279
第10章　分区/280
10.1　分区概述/281
10.2　分区类型/283
10.2.1　RANGE分区/283
10.2.2　LIST分区/289
10.2.3　HASH分区/291
10.2.4　KEY分区/293
10.2.5　COLUMNS分区/293
10.3　子分区/295
10.4　分区中的NULL值/298
10.5　分区和性能/301
10.6　在表和分区间交换数据/305
10.7　小结/307
