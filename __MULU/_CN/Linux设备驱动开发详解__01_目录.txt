
第1篇 Linux设备驱动入门
　第1章 设备驱动概述
　　1.1 设备驱动的作用
　　1.2 无操作系统时的设备驱动
　　1.3 有操作系统时的设备驱动
　　1.4 Linux设备驱动
　　　1.4.1 设备的分类及特点
　　　1.4.2 Linux设备驱动与整个软硬件系统的关系
　　　1.4.3 编写Linux设备驱动的技术基础
　　　1.4.4 Linux设备驱动的学习方法
　　1.5 设备驱动的HelloWorld：LED驱动
　　　1.5.1 无操作系统时的LED驱动
　　　1.5.2 Linux系统下的LED驱动
　第2章 驱动设计的硬件基础
　　2.1 处理器
　　　2.1.1 通用处理器
　　　2.1.2 数字信号处理器
　　2.2 存储器
　　2.3 接口与总线
　　　2.3.1 串口
　　　2.3.2 I2C总线
　　　2.3.3 USB
　　　2.3.4 以太网接口
　　　2.3.5 ISA总线
　　　2.3.6 PCI和cPCI
　　2.4 CPLD和FPGA
　　　2.5 原理图分析
　　　2.5.1 原理图分析的内容
　　　2.5.2 原理图的分析方法
　　2.6 硬件时序分析
　　　2.6.1 时序分析的概念
　　　2.6.2 典型硬件时序
　　2.7 仪器仪表使用
　　　2.7.1 万用表
　　　2.7.2 示波器
　　　2.7.3 逻辑分析仪
　　2.8 总结
　第3章 Linux内核及内核编程
　　3.1 Linux内核的发展与演变
　　3.2 Linux2.6内核的特点
　　3.3 Linux内核的组成
　　　3.3.1 Linux内核源代码目录结构
　　　3.3.2 Linux内核的组成部分
　　　3.3.3 Linux内核空间与用户空间
　　3.4 Linux内核的编译及加载
　　　3.4.1 Linux内核的编译
　　　3.4.2 Kconfig和Makefile
　　　3.4.3 Linux内核的引导
　　3.5 Linux下的C编程
　　　3.5.1 Linux程序命名习惯
　　　3.5.2 GNUC与ANSIC
　　　3.5.3 do{}while(0)
　　　3.5.4 goto
　　3.6 总结
第2篇 Linux设备驱动核心理论
　第4章 Linux内核模块
　　4.1 Linux内核模块简介
　　4.2 Linux内核模块的程序结构
　　4.3 模块加载函数
　　4.4 模块卸载函数
　　4.5 模块参数
　　4.6 导出符号
　　4.7 模块声明与描述
　　4.8 模块的使用计数
　　4.9 模块的编译
　　4.10 模块与GPL
　　4.11 总结
　第5章 Linux文件系统与设备文件系统
　　5.1 Linux文件操作
　　　5.1.1 文件操作的相关系统调用
　　　5.1.2 C库函数的文件操作
　　5.2 Linux文件系统
　　　5.2.1 Linux文件系统目录结构
　　　5.2.2 Linux文件系统与设备驱动
　　5.3 devfs设备文件系统
　　5.4 udev设备文件系统
　　　5.4.1 udev与devfs的区别
　　　5.4.2 sysfs文件系统与Linux设备模型
　　　5.4.3 udev的组成
　　　5.4.4 udev规则文件
　　　5.4.5 创建和配置udev
　　5.5 总结
　第6章 字符设备驱动
　　6.1 Linux字符设备驱动结构
　　　6.1.1 cdev结构体
　　　6.1.2 分配和释放设备号
　　　6.1.3 file_operations结构体
　　　6.1.4 Linux字符设备驱动的组成
　　6.2 globalmem虚拟设备实例描述
　　6.3 globalmem设备驱动
　　　6.3.1 头文件、宏及设备结构体
　　　6.3.2 加载与卸载设备驱动
　　　6.3.3 读写函数
　　　6.3.4 seek()函数
　　　6.3.5 ioctl()函数
　　　6.3.6 使用文件私有数据
　　6.4 globalmem驱动在用户空间的验证
　　6.5 总结
　第7章 Linux设备驱动中的并发控制
　　7.1 并发与竞态
　　7.2 中断屏蔽
　　7.3 原子操作
　　　7.3.1 整型原子操作
　　　7.3.2 位原子操作
　　7.4 自旋锁
　　　7.4.1 自旋锁的使用
　　　7.4.2 读写自旋锁
　　　7.4.3 顺序锁
　　　7.4.4 读-拷贝-更新
　　7.5 信号量
　　　7.5.1 信号量的使用
　　　7.5.2 信号量用于同步
　　　7.5.3 完成量用于同步
　　　7.5.4 自旋锁vs信号量
　　　7.5.5 读写信号量
　　7.6 互斥体
　　7.7 增加并发控制后的globalmem驱动
　　7.8 总结
　第8章 Linux设备驱动中的阻塞与非阻塞I/O
　　8.1 阻塞与非阻塞I/O
　　　8.1.1 等待队列
　　　8.1.2 支持阻塞操作的globalfifo设备驱动
　　　8.1.3 在用户空间验证globalfifo的读写
　　8.2 轮询操作
　　　8.2.1 轮询的概念与作用
　　　8.2.2 应用程序中的轮询编程
　　　8.2.3 设备驱动中的轮询编程
　　8.3 支持轮询操作的globalfifo驱动
　　　8.3.1 在globalfifo驱动中增加轮询操作
　　　8.3.2 在用户空间验证globalfifo设备的轮询
　　8.4 总结
　第9章 Linux设备驱动中的异步通知与异步I/O
　　9.1 异步通知的概念与作用
　　9.2 Linux异步通知编程
　　　9.2.1 Linux信号
　　　9.2.2 信号的接收
　　　9.2.3 信号的释放
　　9.3 支持异步通知的globalfifo驱动
　　　9.3.1 在globalfifo驱动中增加异步通知
　　　9.3.2 在用户空间验证globalfifo的异步通知
　　9.4 Linux2.6异步I/O
　　　9.4.1 AIO概念与GNUC库函数
　　　9.4.2 使用信号作为AIO的通知
　　　9.4.3 使用回调函数作为AIO的通知
　　　9.4.4 AIO与设备驱动
　　9.5 总结
　第10章 中断与时钟
　　10.1 中断与定时器
　　10.2 Linux中断处理程序架构
　　10.3 Linux中断编程
　　　10.3.1 申请和释放中断
　　　10.3.2 使能和屏蔽中断
　　　10.3.3 底半部机制
　　　10.3.4 实例：S3C2410实时钟中断
　　10.4 中断共享
　　10.5 内核定时器
　　　10.5.1 内核定时器编程
　　　10.5.2 实例：秒字符设备
　　10.6 内核延时
　　　10.6.1 短延迟
　　　10.6.2 长延迟
　　　10.6.3 睡着延迟
　　10.7 总结
　第11章 内存与I/O访问
　　11.1 CPU与内存和I/O
　　　11.1.1 内存空间与I/O空间
　　　11.1.2 内存管理单元MMU
　　11.2 Linux内存管理
　　11.3 内存存取
　　　11.3.1 用户空间内存动态申请
　　　11.3.2 内核空间内存动态申请
　　　11.3.3 虚拟地址与物理地址关系
　　11.4 设备I/O端口和I/O内存的访问
　　　11.4.1 LinuxI/O端口和I/O内存访问接口
　　　11.4.2 申请与释放设备I/O端口和I/O内存
　　　11.4.3 设备I/O端口和I/O内存访问流程
　　　11.4.4 将设备地址映射到用户空间
　　11.5 I/O内存静态映射
　　11.6 DMA
　　　11.6.1 DMA与Cache一致性
　　　11.6.2 Linux下的DMA编程
　　11.7 总结
　第12章 Linux字符设备驱动综合实例
　　12.1 按键的设备驱动
　　　12.1.1 按键的硬件原理
　　　12.1.2 按键驱动中的数据结构
　　　12.1.3 按键驱动的模块加载和卸载函数
　　　12.1.4 按键设备驱动中断、定时器处理程序
　　　12.1.5 按键设备驱动的打开、释放函数
　　　12.1.6 按键设备驱动读函数
　　12.2 触摸屏的设备驱动
　　　12.2.1 触摸屏的硬件原理
　　　12.2.2 触摸屏设备驱动中数据结构
　　　12.2.3 触摸屏驱动中的硬件控制
　　　12.2.4 触摸屏驱动模块加载和卸载函数
　　　12.2.5 触摸屏驱动中断、定时器处理程序
　　　12.2.6 触摸屏设备驱动的打开、释放函数
　　　12.2.7 触摸屏设备驱动的读函数
　　　12.2.8 触摸屏设备驱动的轮询与异步通知
　　　12.2.9 Linux输入子系统
　　　12.3 DSPHPI的设备驱动
　　　12.3.1 HPI接口的硬件原理
　　　12.3.2 HPI接口设备驱动中数据结构
　　　12.3.3 HPI接口设备驱动的读写函数
　　12.4 NVRAM设备驱动
　　　12.4.1 NVRAM设备驱动的数据结构
　　　12.4.2 NVRAM设备驱动的模块加载与卸载函数
　　　12.4.3 NVRAM设备驱动读写函数
　　　12.4.4 NVRAM设备驱动的seek函数
　　12.5 看门狗设备驱动
　　　12.5.1 看门狗硬件原理
　　　12.5.2 看门狗驱动中的数据结构
　　　12.5.3 看门狗驱动模块的加载和卸载函数
　　　12.5.4 看门狗驱动探测和移除函数
　　　12.5.5 看门狗驱动的挂起和恢复函数
　　　12.5.6 看门狗驱动的打开和释放函数
　　　12.5.7 看门狗驱动写函数
　　12.6 总结
第3篇 Linux设备驱动实例
　第13章 Linux块设备驱动
　　13.1 块设备的I/O操作特点
　　13.2 Linux块设备驱动结构
　　　13.2.1 block_device_operations结构体
　　　13.2.2 gendisk结构体
　　　13.2.3 request与bio结构体
　　　13.2.4 块设备驱动注册与注销
　　13.3 Linux块设备驱动的模块加载与卸载
　　13.4 块设备的打开与释放
　　13.5 块设备驱动的ioctl函数
　　13.6 块设备驱动的I/O请求处理
　　　13.6.1 使用请求队列
　　　13.6.2 不使用请求队列
　　13.7 实例1：RamDisk驱动
　　　13.7.1 RamDisk的硬件原理
　　　13.7.2 RamDisk驱动模块的加载与卸载
　　　13.7.3 RamDisk设备驱动block_device_operations及成员函数
　　　13.7.4 RamDiskI/O请求处理
　　13.8 实例2：IDE硬盘设备驱动
　　　13.8.1 IDE硬盘设备原理
　　　13.8.2 IDE硬盘设备驱动的block_device_operations及成员函数
　　　13.8.3 IDE硬盘设备驱动的I/O请求处理
　　　13.8.4 在内核中增加对新系统IDE设备的支持
　　13.9 总结
　第14章 Linux终端设备驱动
　　14.1 终端设备
　　14.2 终端设备驱动结构
　　14.3 终端设备驱动的初始化与释放
　　　14.3.1 模块加载与卸载函数
　　　14.3.2 打开与关闭函数
　　14.4 数据发送和接收
　　14.5 tty线路设置
　　　14.5.1 线路设置用户空间接口
　　　14.5.2 tty驱动的set_termios函数
　　　14.5.3 tty驱动的tiocmget和tiocmset函数
　　　14.5.4 tty驱动的ioctl函数
　　14.6 UART设备驱动
　　14.7 S3C2410UART的驱动实例
　　　14.7.1 S3C2410串口硬件描述
　　　14.7.2 S3C2410串口驱动的数据结构
　　　14.7.3 S3C2410串口驱动的初始化与释放
　　　14.7.4 S3C2410串口数据收发
　　　14.7.5 S3C2410串口线路设置
　　14.8 总结
　第15章 Linux的I2C核心、总线与设备驱动
　　15.1 Linux的I2C体系结构
　　15.2 LinuxI2C核心
　　15.3 LinuxI2C总线驱动
　　　15.3.1 I2C适配器驱动加载与卸载
　　　15.3.2 I2C总线通信方法
　　15.4 LinuxI2C设备驱动
　　　15.4.1 LinuxI2C设备驱动的模块加载与卸载
　　　15.4.2 LinuxI2C设备驱动的i2c_driver成员函数
　　　15.4.3 LinuxI2C设备驱动的文件操作接口
　　　15.4.4 Linux的i2c-dev.c文件分析
　　15.5 S3C2410I2C总线驱动实例
　　　15.5.1 S3C2410I2C控制器硬件描述
　　　15.5.2 S3C2410I2C总线驱动总体分析
　　　15.5.3 S3C2410I2C适配器驱动的模块加载与卸载
　　　15.5.4 S3C2410I2C总线通信方法
　　15.6 SAA7113H视频AD芯片的I2C设备驱动实例
　　　15.6.1 SAA7113H视频AD芯片硬件描述
　　　15.6.2 SAA7113H视频AD芯片驱动的模块加载与卸载
　　　15.6.3 SAA7113H设备驱动的i2c_driver成员函数
　　15.7 总结
　第16章 Linux网络设备驱动
　　16.1 Linux网络设备驱动的结构
　　　16.1.1 网络协议接口层
　　　16.1.2 网络设备接口层
　　　16.1.3 设备驱动功能层
　　　16.1.4 网络设备与媒介层
　　16.2 网络设备驱动的注册与注销
　　16.3 网络设备的初始化
　　16.4 网络设备的打开与释放
　　16.5 数据发送流程
　　16.6 数据接收流程
　　16.7 网络连接状态
　　16.8 参数设置和统计数据
　　16.9 CS8900网卡设备驱动实例
　　　16.9.1 CS8900网卡硬件描述
　　　16.9.2 CS8900网卡驱动设计分析
　　　16.9.3 CS8900网卡注册、初始化与注销
　　　16.9.4 CS8900网卡发送数据流程
　　　16.9.5 CS8900网卡接收数据流程
　　16.10 总结
　第17章 Linux音频设备驱动
　　17.1 数字音频设备
　　17.2 音频设备硬件接口
　　　17.2.1 PCM接口
　　　17.2.2 IIS接口
　　　17.2.3 AC97接口
　　17.3 LinuxOSS音频设备驱动
　　　17.3.1 OSS驱动的组成
　　　17.3.2 mixer接口
　　　17.3.3 dsp接口
　　　17.3.4 OSS用户空间编程
　　17.4 LinuxALSA音频设备驱动
　　　17.4.1 ALSA的组成
　　　17.4.2 card和组件管理
　　　17.4.3 PCM设备
　　　17.4.4 控制接口
　　　17.4.5 AC97API接口
　　　17.4.6 ALSA用户空间编程
　　17.5 S3C2410+UDA1341OSS驱动实例
　　　17.5.1 S3C2410与UDA1341接口硬件描述
　　　17.5.2 注册dsp和mixer接口
　　　17.5.3 mixer接口的I/O控制函数
　　　17.5.4 dsp接口音频数据传输
　　17.6 SA1100+UDA1341ALSA驱动实例
　　　17.6.1 card注册与注销
　　　17.6.2 PCM设备的实现
　　　17.6.3 控制接口的实现
　　17.7 PXA255+AC97ALSA驱动实例
　　17.8 总结
　第18章 LCD设备驱动
　　18.1 LCD硬件原理
　　18.2 帧缓冲
　　　18.2.1 帧缓冲的概念
　　　18.2.2 显示缓冲区与显示点
　　　18.2.3 Linux帧缓冲相关数据结构与函数
　　18.3 Linux帧缓冲设备驱动结构
　　18.4 帧缓冲设备驱动的模块加载与卸载函数
　　18.5 帧缓冲设备显示缓冲区的申请与释放
　　18.6 帧缓冲设备的参数设置
　　　18.6.1 定时参数
　　　18.6.2 像素时钟
　　　18.6.3 颜色位域
　　　18.6.4 固定参数
　　18.7 帧缓冲设备驱动的fb_ops成员函数
　　18.8 LCD设备驱动的读写、mmap和ioctl函数
　　18.9 帧缓冲设备的用户空间访问
　　18.10 Linux图形用户界面
　　　18.10.1 Qt-X11/QtEmbedded/Qtopia
　　　18.10.2 Microwindows/Nano-X
　　　18.10.3 MiniGUI
　　18.11 实例：S3C2410LCD设备驱动
　　　18.11.1 S3C2410LCD控制器硬件描述
　　　18.11.2 S3C2410LCD驱动的模块加载与卸载函数
　　　18.11.3 S3C2410LCD驱动的探测与移除函数
　　　18.11.4 S3C2410LCD驱动挂起与恢复函数
　　　18.11.5 S3C2410LCD驱动的fb_ops成员函数
　　18.12 总结
　第19章 Flash设备驱动
　　19.1 LinuxFlash驱动结构
　　　19.1.1 LinuxMTD系统层次
　　　19.1.2 LinuxMTD系统接口
　　　19.1.3 MTD用户空间编程
　　19.2 NORFlash驱动
　　19.3 NANDFlash驱动
　　19.4 NORFlash驱动实例：S3C2410外围的NORFlash驱动
　　19.5 NANDFlash驱动实例：S3C2410外围的NANDFlash驱动
　　　19.5.1 S3C2410NAND控制器硬件描述
　　　19.5.2 nand_chip初始化和成员函数
　　　19.5.3 NAND设备驱动初始化与释放
　　19.6 Flash文件系统的建立
　　　19.6.1 Flash转换层
　　　19.6.2 CramFS
　　　19.6.3 JFFS/JFFS2
　　　19.6.4 YAFFS/YAFFS2
　　19.7 总结
　第20章 USB主机与设备驱动
　　20.1 LinuxUSB驱动层次
　　　20.1.1 主机侧与设备侧USB驱动
　　　20.1.2 设备、配置、接口、端点
　　20.2 USB主机驱动
　　　20.2.1 USB主机驱动的整体结构
　　　20.2.2 实例：S3C2410USB主机驱动
　　20.3 USB设备驱动
　　　20.3.1 USB设备驱动整体结构
　　　20.3.2 USB请求块(URB)
　　　20.3.3 探测和断开函数
　　　20.3.4 USB骨架程序
　　20.4 USB设备驱动实例
　　　20.4.1 USB串口驱动
　　　20.4.2 USB键盘驱动
　　20.5 总结
　第21章 PCI设备驱动
　　21.1 PCI总线与配置空间
　　　21.1.1 PCI总线的Linux描述
　　　21.1.2 PCI设备的Linux描述
　　　21.1.3 PCI配置空间访问
　　21.2 PCI设备驱动结构
　　　21.2.1 pci_driver结构体
　　　21.2.2 PCI设备驱动的组成
　　　21.2.3 旧版内核的PCI设备探测
　　21.3 实例：Intel810主板声卡驱动
　　21.4 总结
第4篇 Linux设备驱动测试、移植
　第22章 Linux设备驱动的调试
　　22.1 Linux开发环境建设
　　　22.1.1 实验室建设
　　　22.1.2 工具链
　　　22.1.3 串口工具
　　22.2 GDB调试器用法
　　　22.2.1 GDB基本用法
　　　22.2.2 DDD图形界面调试工具
　　22.3 Linux内核调试
　　22.4 内核打印信息-printk()
　　22.5 使用/proc
　　22.6 Oops
　　22.7 监视工具
　　22.8 内核调试器
　　　22.8.1 kcore
　　　22.8.2 KDB
　　　22.8.3 KGDB
　　22.9 使用仿真器调试内核
　　22.10 应用程序调试
　　22.11 总结
　第23章 Linux设备驱动的移植
　　23.1 编写可移植的设备驱动
　　　23.1.1 可移植的数据类型
　　　23.1.2 结构体对界
　　　23.1.3 LittleEndian与BigEndian
　　　23.1.4 内存页面大小
　　23.2 巧用同类设备驱动
　　　23.2.1 巧用demo板驱动
　　　23.2.2 巧用类似芯片的驱动程序
　　　23.2.3 借用芯片厂商的范例程序
　　23.3 从Linux2.4移植设备驱动到Linux2.6
　　23.4 Linux与其他操作系统之间的驱动移植
　　23.5 总结
参考文献 