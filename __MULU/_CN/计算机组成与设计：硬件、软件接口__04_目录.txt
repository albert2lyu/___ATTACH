
出版者的话
译者序
前言
第1章　计算机概要与技术1
　1.1　引言1
　　1.1.1　计算应用的分类及其特性2
　　1.1.2　你能从本书学到什么3
　1.2　程序概念入门4
　1.3　硬件概念入门7
　　1.3.1　剖析鼠标8
　　1.3.2　显示器8
　　1.3.3　打开机箱9
　　1.3.4　数据安全12
　　1.3.5　与其他计算机通信13
　　1.3.6　处理器和存储器制造技术14
　1.4　性能15
　　1.4.1　性能的定义15
　　1.4.2　性能的测量17
　　1.4.3　CPU性能及其因素18
　　1.4.4　指令的性能19
　　1.4.5　经典的CPU性能公式19
　1.5　功耗墙21
　1.6　沧海巨变：从单处理器向多处理器转变23
　1.7　实例：制造以及AMD Opteron X4基准25
　　1.7.1　SPEC CPU基准测试程序27
　　1.7.2　SPEC功耗基准测试程序28
　1.8　谬误与陷阱29
　1.9　本章小结31
　1.10　拓展阅读32
　1.11　练习题32
第2章　指令：计算机的语言42
　2.1　引言42
　2.2　计算机硬件的操作43
　2.3　计算机硬件的操作数46
　　2.3.1　存储器操作数47
　　2.3.2　常数或立即数操作数49
　2.4　有符号和无符号数50
　2.5　计算机中指令的表示54
　2.6　逻辑操作59
　2.7　决策指令61
　　2.7.1　循环62
　　2.7.2　case/switch语句64
　2.8　计算机硬件对过程的支持65
　　2.8.1　使用更多的寄存器66
　　2.8.2　嵌套过程68
　　2.8.3　在栈中为新数据分配空间69
　　2.8.4　在堆中为新数据分配空间70
　2.9　人机交互72
　2.10　MIPS中32位立即数和地址的寻址75
　　2.10.1　32位立即数75
　　2.10.2　分支和跳转中的寻址76
　　2.10.3　MIPS寻址模式总结78
　　2.10.4　机器语言解码79
　2.11　并行与指令：同步81
　2.12　翻译并执行程序83
　　2.12.1　编译器84
　　2.12.2　汇编器84
　　2.12.3　链接器85
　　2.12.4　加载器87
　　2.12.5　动态链接库87
　　2.12.6　启动一个Java程序88
　2.13　以一个C排序程序为例89
　　2.13.1　swap过程89
　　2.13.2　sort过程90
　2.14　数组与指针95
　　2.14.1　用数组实现clear96
　　2.14.2　用指针实现clear96
　　2.14.3　比较两个版本的clear97
　2.15　高级内容：编译C语言和解释Java语言98
　2.16　实例：ARM指令集98
　　2.16.1　寻址模式99
　　2.16.2　比较和条件分支100
　　2.16.3　ARM的特色100
　2.17　实例：x86指令集101
　　2.17.1　Intel x86的改进101
　　2.17.2　x86寄存器和数据寻址模式103
　　2.17.3　x86整数操作104
　　2.17.4　x86指令编码106
　　2.17.5　x86总结107
　2.18　谬误与陷阱107
　2.19　本章小结108
　2.20　拓展阅读110
　2.21　练习题110
第3章　计算机的算术运算135
　3.1　引言135
　3.2　加法和减法135
　　3.2.1　多媒体算术运算137
　　3.2.2　小结138
　3.3　乘法139
　　3.3.1　顺序的乘法算法和硬件139
　　3.3.2　有符号乘法141
　　3.3.3　更快速的乘法142
　　3.3.4　MIPS中的乘法142
　　3.3.5　小结142
　3.4　除法143
　　3.4.1　除法算法及其硬件结构143
　　3.4.2　有符号除法145
　　3.4.3　更快速的除法146
　　3.4.4　MIPS中的除法146
　　3.4.5　小结147
　3.5　浮点运算148
　　3.5.1　浮点表示149
　　3.5.2　浮点加法152
　　3.5.3　浮点乘法154
　　3.5.4　MIPS中的浮点指令157
　　3.5.5　算术精确性162
　　3.5.6　小结164
　3.6　并行性和计算机算术：结合律165
　3.7　实例：x86的浮点165
　　3.7.1　x86浮点体系结构166
　　3.7.2　Intel SIMD流扩展2（SSE2）浮点体系结构167
　3.8　谬误与陷阱168
　3.9　本章小结170
　3.10　拓展阅读172
　3.11　练习题173
第4章　处理器182
　4.1　引言182
　　4.1.1　一个基本的MIPS实现183
　　4.1.2　实现方式概述183
　4.2　逻辑设计惯例185
　4.3　建立数据通路187
　4.4　一个简单的实现机制192
　　4.4.1　ALU控制192
　　4.4.2　主控制单元的设计194
　　4.4.3　数据通路的操作197
　　4.4.4　控制的结束199
　　4.4.5　为什么不使用单周期实现方式201
　4.5　流水线概述202
　　4.5.1　面向流水线的指令集设计205
　　4.5.2　流水线冒险205
　　4.5.3　对流水线概述的小结210
　4.6　流水线数据通路及其控制211
　　4.6.1　图形化表示的流水线219
　　4.6.2　流水线控制222
　4.7　数据冒险：转发与阻塞225
　4.8　控制冒险234
　　4.8.1　假定分支不发生234
　　4.8.2　缩短分支的延迟235
　　4.8.3　动态分支预测237
　　4.8.4　流水线小结239
　4.9　异常240
　　4.9.1　异常在MIPS体系结构中的处理241
　　4.9.2　在流水线实现中的异常242
　4.10　并行和高级指令级并行245
　　4.10.1　推测的概念246
　　4.10.2　静态多发射处理器247
　　4.10.3　动态多发射处理器250
　4.11　实例：AMD Opteron X4（Barcelona）流水线253
　4.12　高级主题：通过硬件设计语言描述和建模流水线来介绍数字设计以及更多流水线示例255
　4.13　谬误与陷阱255
　4.14　本章小结256
　4.15　拓展阅读257
　4.16　练习题257
第5章　大容量和高速度：开发存储器层次结构280
　5.1　引言280
　5.2　cache的基本原理283
　　5.2.1　cache访问285
　　5.2.2　cache缺失处理288
　　5.2.3　写操作处理289
　　5.2.4　一个cache的例子:内置FastMATH处理器290
　　5.2.5　设计支持cache的存储系统292
　　5.2.6　小结294
　5.3　cache性能的评估和改进295
　　5.3.1　通过更灵活地放置块来减少cache缺失297
　　5.3.2　在cache中查找一个块300
　　5.3.3　替换块的选择302
　　5.3.4　使用多级cache结构减少缺失代价302
　　5.3.5　小结305
　5.4　虚拟存储器305
　　5.4.1　页的存放和查找308
　　5.4.2　缺页309
　　5.4.3　关于写312
　　5.4.4　加快地址转换：TLB312
　　5.4.5　集成虚拟存储器、TLB和cache315
　　5.4.6　虚拟存储器中的保护317
　　5.4.7　处理TLB缺失和缺页318
　　5.4.8　小结322
　5.5　存储器层次结构的一般架构323
　　5.5.1　问题1：一个块可以被放在何处323
　　5.5.2　问题2：如何找到一个块324
　　5.5.3　问题3：当cache缺失时替换哪一块325
　　5.5.4　问题4：写操作如何处理325
　　5.5.5　3C：一种理解存储器层次结构行为的直观模型326
　5.6　虚拟机328
　　5.6.1　虚拟机监视器的必备条件329
　　5.6.2　指令集系统结构（缺乏）对虚拟机的支持329
　　5.6.3　保护和指令集系统结构329
　5.7　使用有限状态机来控制简单的cache330
　　5.7.1　一个简单的cache330
　　5.7.2　有限状态机331
　　5.7.3　一个简单的cache控制器的有限状态机333
　5.8　并行与存储器层次结构：cache一致性334
　　5.8.1　实现一致性的基本方案335
　　5.8.2　监听协议335
　5.9　高级内容：实现cache控制器336
　5.10　实例：AMD Opteron X4(Barcelona)和Intel Nehalem的存储器层次结构337
　　5.10.1　Nehalem和Opteron的存储器层次结构337
　　5.10.2　减少缺失代价的技术339
　5.11　谬误和陷阱340
　5.12　本章小结342
　5.13　拓展阅读343
　5.14　练习题343
第6章　存储器和其他I/O主题355
　6.1　引言355
　6.2　可信度、可靠性和可用性357
　6.3　磁盘存储器359
　6.4　快闪式存储器362
　6.5　连接处理器、内存以及I/O设备363
　　6.5.1　互联基础364
　　6.5.2　x86处理器的I/O互联365
　6.6　为处理器、内存和操作系统提供I/O设备接口366
　　6.6.1　给I/O设备发送指令367
　　6.6.2　与处理器通信368
　　6.6.3　中断优先级369
　　6.6.4　在设备与内存之间传输数据370
　　6.6.5　直接存储器访问和内存系统371
　6.7　I/O性能度量：磁盘和文件系统的例子372
　　6.7.1　事务处理I/O基准程序372
　　6.7.2　文件系统和Web I/O的基准程序373
　6.8　设计I/O系统373
　6.9　并行性与I/O：廉价磁盘冗余阵列374
　　6.9.1　无冗余(RAID 0)376
　　6.9.2　镜像（RAID 1）376
　　6.9.3　错误检测和纠错码（RAID 2）376
　　6.9.4　位交叉奇偶校验（RAID 3）376
　　6.9.5　块交叉奇偶校验（RAID 4）376
　　6.9.6　分布式块交叉奇偶校验（RAID 5）377
　　6.9.7　P+Q冗余（RAID 6）378
　　6.9.8　RAID小结378
　6.10　实例：Sun Fire x4150服务器379
　6.11　高级主题：网络383
　6.12　谬误与陷阱383
　6.13　本章小结386
　6.14　拓展阅读387
　6.15　练习题387
第7章　多核、多处理器和集群394
　7.1　引言394
　7.2　创建并行处理程序的难点396
　7.3　共享存储多处理器398
　7.4　集群和其他消息传递多处理器400
　7.5　硬件多线程403
　7.6　SISD、MIMD、SIMD、SPMD和向量机404
　　7.6.1　在x86中的SIMD：多媒体扩展405
　　7.6.2　向量机406
　　7.6.3　向量与标量的对比407
　　7.6.4　向量与多媒体扩展的对比408
　7.7　图形处理单元简介408
　　7.7.1　NVIDIA GPU体系结构简介410
　　7.7.2　深入理解GPU411
　7.8　多处理器网络拓扑简介412
　7.9　多处理器基准测试程序415
　7.10　Roofline：一个简单的性能模型417
　　7.10.1　Roofline模型418
　　7.10.2　两代Opteron的比较419
　7.11　实例：使用屋顶线模型评估四种多核处理器422
　　7.11.1　4个多核系统422
　　7.11.2　稀疏矩阵424
　　7.11.3　结构化网格425
　　7.11.4　生产率426
　7.12　谬误与陷阱427
　7.13　本章小结428
　7.14　拓展阅读429
　7.15　练习题429
附录A　图形和计算GPU439
　A.1　引言439
　　A.1.1　GPU发展简史439
　　A.1.2　异构系统440
　　A.1.3　GPU发展成了可扩展的并行处理器440
　　A.1.4　为什么使用CUDA和GPU计算440
　　A.1.5　GPU统一了图形和计算441
　　A.1.6　GPU可视化计算的应用441
　A.2　GPU系统架构441
　　A.2.1　异构CPU-GPU系统架构442
　　A.2.2　GPU接口和驱动443
　　A.2.3　图形逻辑流水线443
　　A.2.4　将图形流水线映射到统一的GPU处理器443
　　A.2.5　基本的统一GPU结构444
　A.3　可编程GPU445
　　A.3.1　为实时图形编程446
　　A.3.2　逻辑图形流水线446
　　A.3.3　图形渲染程序447
　　A.3.4　像素渲染示例447
　　A.3.5　并行计算应用编程448
　　A.3.6　使用CUDA进行可扩展并行编程449
　　A.3.7　一些限制453
　　A.3.8　体系结构隐含的问题453
　A.4　多线程的多处理器架构454
　　A.4.1　大规模多线程454
　　A.4.2　多处理器体系结构455
　　A.4.3　单指令多线程（SIMT）456
　　A.4.4　SIMT warp执行和分支457
　　A.4.5　管理线程和线程块457
　　A.4.6　线程指令458
　　A.4.7　指令集架构（ISA）458
　　A.4.8　流处理器（SP）461
　　A.4.9　特殊功能单元（SFU）461
　　A.4.10　与其他多处理器的比较461
　　A.4.11　多线程多处理器总结462
　A.5　并行存储系统462
　　A.5.1　DRAM的考虑462
　　A.5.2　cache463
　　A.5.3　MMU463
　　A.5.4　存储器空间463
　　A.5.5　全局存储器463
　　A.5.6　共享存储器464
　　A.5.7　局部存储器464
　　A.5.8　常量存储器464
　　A.5.9　纹理存储器464
　　A.5.10　表面465
　　A.5.11　load/store访问465
　　A.5.12　ROP465
　A.6　浮点算术465
　　A.6.1　支持的格式465
　　A.6.2　基本算术465
　　A.6.3　专用算术466
　　A.6.4　性能467
　　A.6.5　双精度467
　A.7　资料：NVIDIA GeForce 8800468
　　A.7.1　流处理器阵列（SPA）468
　　A.7.2　纹理/处理器簇（TPC）469
　　A.7.3　流多处理器（SM）470
　　A.7.4　指令集471
　　A.7.5　流处理器（SP）471
　　A.7.6　特殊功能单元（SFU）471
　　A.7.7　光栅化471
　　A.7.8　光栅操作处理器（ROP）和存储系统471
　　A.7.9　可扩展性472
　　A.7.10　性能472
　　A.7.11　密集线性代数性能472
　　A.7.12　FFT性能473
　　A.7.13　排序性能474
　A.8　资料：将应用映射到GPU474
　　A.8.1　稀疏矩阵475
　　A.8.2　在共享存储器中进行缓存477
　　A.8.3　扫描和归约478
　　A.8.4　基数排序480
　　A.8.5　GPU上的N-Body应用482
　A.9　谬误与陷阱486
　A.10　小结489
　A.11　拓展阅读489
附录B　汇编器、链接器和SPIM仿真器490
　B.1　引言490
　　B.1.1　什么时候使用汇编语言493
　　B.1.2　汇编语言的缺点493
　B.2　汇编器494
　　B.2.1　目标文件的格式495
　　B.2.2　附加工具496
　B.3　链接器498
　B.4　加载499
　B.5　内存的使用499
　B.6　过程调用规范500
　　B.6.1　过程调用502
　　B.6.2　过程调用举例503
　　B.6.3　另外一个过程调用的例子505
　B.7　异常和中断507
　B.8　输入和输出509
　B.9　SPIM511
　B.10　MIPS R2000汇编语言513
　　B.10.1　寻址方式514
　　B.10.2　汇编语法515
　　B.10.3　MIPS指令编码515
　　B.10.4　指令格式516
　　B.10.5　常数操作指令520
　　B.10.6　比较指令520
　　B.10.7　分支指令521
　　B.10.8　跳转指令523
　　B.10.9　陷阱指令523
　　B.10.10　取数指令525
　　B.10.11　保存指令526
　　B.10.12　数据传送指令527
　　B.10.13　浮点运算指令528
　　B.10.14　异常和中断指令532
　B.11　小结533
　B.12　参考文献533
　B.13　练习题533
