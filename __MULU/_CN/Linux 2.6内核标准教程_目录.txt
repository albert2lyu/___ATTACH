
第1章　Linux内核学习基础　1
1.1　为什么研究Linux内核　2
1.1.1　Linux的历史来源　2
1.1.2　Linux的发展现状　3
1.1.3　Linux的前景展望　3
1.2　选择什么版本进行研究　3
1.3　内核基本结构　4
1.3.1　内核在操作系统中的地位　4
1.3.2　Linux 2.6内核源代码目录树简介　5
1.3.3　Linux 2.6内核的新特性　8
1.4　如何阅读本书　9
1.4.1　内核探索工具　10
1.4.2　推荐阅读方法　12

第2章　引导过程分析　14
2.1　内核镜像的构建过程　15
2.1.1　编译内核的步骤及分析　15
2.1.2　内核镜像构建过程分析　16
2.2　系统引导过程分析　18
2.2.1　傀儡引导扇区　18
2.2.2　探测系统资源　21
2.2.3　解压内核镜像　35
2.2.4　进入保护模式　40
2.2.5　系统最终初始化　47
2.3　系统引导过程总结　47

第3章　内存管理　50
3.1　基础知识　51
3.1.1　存储器地址　51
3.1.2　分段机制　52
3.1.3　分页机制　59
3.2　内核页表的初始化过程　65
3.2.1　启用分页机制　65
3.2.2　构建内核页表　68
3.3　物理内存的描述方法　76
3.3.1　内存节点　77
3.3.2　内存区域　81
3.3.3　物理页框　85
3.4　物理内存的初始化过程　86
3.4.1　探测系统物理内存　87
3.4.2　初始化内存分配器　89
3.5　物理内存的分配与回收　101
3.5.1　伙伴分配算法　101
3.5.2　对象缓冲技术　103
3.6　内核地址空间　105
3.6.1　常规映射地址空间　105
3.6.2　固定映射地址空间　107
3.6.3　长久内核映射空间　109
3.6.4　临时内核映射空间　116
3.6.5　非连续映射地址空间　119

第4章　进程管理　128
4.1　进程与线程的概念　129
4.1.1　程序与进程　129
4.1.2　进程与线程　129
4.2　进程描述符　131
4.2.1　进程标识符　132
4.2.2　进程的状态　132
4.2.3　进程上下文　134
4.2.4　当前进程　139
4.3　进程的组织形式　143
4.3.1　进程标识符构成的哈希表　143
4.3.2　所有进程构成的双向链表　148
4.3.3　执行态进程组成的运行队列　149
4.3.4　阻塞态进程组成的等待队列　152
4.4　进程的创建过程　155
4.4.1　进程创建的接口函数　156
4.4.2　进程创建的处理过程　162
4.5　进程调度算法　177
4.5.1　进程的分类　178
4.5.2　进程优先级　178
4.5.3　时间片分配　181
4.5.4　进程调度时机　182
4.6　进程切换过程分析　183
4.6.1　选取合适进程　183
4.6.2　完成上下文切换　184
4.7　空闲进程的初始化　187
4.7.1　空闲进程的内核态栈　187
4.7.2　空闲进程的内存描述符　188
4.7.3　空闲进程的硬件上下文　190
4.7.4　空闲进程的任务状态段　190

第5章　中断和异常　192
5.1　基础知识　193
5.1.1　中断和异常的定义　193
5.1.2　中断和异常的分类　193
5.1.3　中断和异常的对比　194
5.2　处理机制　195
5.2.1　IA32架构下的处理机制　195
5.2.2　Linux内核的实现策略　200
5.3　中断描述符表的初始化　204
5.3.1　中断描述符表的初步初始化　204
5.3.2　中断描述符表的最终初始化　206
5.4　具体处理过程　216
5.4.1　公用的硬件处理阶段　217
5.4.2　中断的软件处理阶段　218
5.4.3　异常的软件处理阶段　229
5.5　延迟处理机制　233
5.5.1　softirq延迟处理　234
5.5.2　tasklet延迟处理　239
5.5.3　work queue延迟处理　242

第6章　时间度量　249
6.1　硬件支持　250
6.1.1　实时钟RTC　250
6.1.2　系统时钟　250
6.2　软件架构　252
6.2.1　相对时间　252
6.2.2　墙上时间　257
6.2.3　内核定时器　257
6.3　时间度量的初始化过程　260
6.3.1　内核定时器初始化　260
6.3.2　系统时钟的初始化　263
6.3.3　初始化时钟中断源　265
6.4　时钟中断处理过程　266
6.4.1　找回遗失的时钟中断　267
6.4.2　更新jiffies_64、xtime　269
6.4.3　对当前进程记账　271
6.4.4　时钟中断处理小结　272
6.5　内核定时器工作原理　273
6.5.1　初始化内核定时器节点　273
6.5.2　激活内核定时器节点　273
6.5.3　内核定时器的处理过程　277
6.6　微秒级延迟　280
6.6.1　微妙级延迟的访问接口　281
6.6.2　微妙级延迟的实现方法　281

第7章　系统调用　285
7.1　系统服务接口的种类　286
7.1.1　系统调用接口　286
7.1.2　应用编程接口　286
7.2　系统调用的访问手段　286
7.2.1　使用封装函数　286
7.2.2　使用通用接口　287
7.2.3　使用内嵌汇编　288
7.3　系统调用的工作机制　289
7.3.1　系统调用的基本要素　290
7.3.2　系统调用门的初始化　292
7.3.3　系统调用的处理过程　292
7.4　系统调用的参数传递　297
7.4.1　少量参数的情况　297
7.4.2　大量参数的情况　298
7.5　如何添加新系统调用　299
7.5.1　前期准备工作　299
7.5.2　添加处理函数　300
7.5.3　测试新系统调用　301
7.6　什么是快速系统调用　302
7.6.1　工作机制　302
7.6.2　实现策略　305
7.6.3　处理过程　309

第8章　内核同步机制　312
8.1　同步基本原理　313
8.1.1　原子变量　313
8.1.2　中断禁用　315
8.1.3　内核态抢占　316
8.2　系统引导过程分析　318
8.2.1　普通自旋锁　318
8.2.2　读写自旋锁　325
8.2.3　顺序自旋锁　331
8.3　信号量机制　334
8.3.1　普通信号量　335
8.3.2　读写信号量　339
8.4　其他同步机制　340
8.4.1　每处理器变量　341
8.4.2　RCU同步机制　345

附录A　Linux内核双向链表　350
A.1　内核链表表头　351
A.2　内核链表遍历　352
A.3　内核链表遍历　353

附录B　跟踪调试内核　354
B.1　安装辅助工具　355
B.2　准备内核镜像　355
B.3　准备根文件系统　355
B.4　进行源码级调试　356

附录C　Linux内核汇编语法　358
C.1　常规汇编语法　359
C.1.1　寄存器前缀　359
C.1.2　立即数前缀　359
C.1.3　操作数顺序　359
C.1.4　操作数宽度　359
C.1.5　内存寻址格式　359
C.2　内嵌汇编语法　360
C.2.1　内嵌汇编举例　360
C.2.2　内嵌汇编格式――格式框架　361
C.2.3　内嵌汇编格式――语句模板　361
C.2.4　内嵌汇编格式――输出列表　361
C.2.5　内嵌汇编格式――输入列表　362
C.2.6　内嵌汇编格式――修饰字符　362
C.2.7　内嵌汇编格式――破坏描述　364

附录D　参考文献　366
D.1　关于IA32体系结构的资源　367
D.2　关于Linux内核的相关资源　367
D.3　关于计算机基本原理的资源　367
D.4　其他相关资源　368

