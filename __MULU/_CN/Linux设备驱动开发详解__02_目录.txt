
第1篇　Linux设备驱动入门

第1章　Linux设备驱动概述及开发环境构建　2
1.1　设备驱动的作用　3
1.2　无操作系统时的设备驱动　3
1.3　有操作系统时的设备驱动　5
1.4　Linux设备驱动　6
1.4.1　设备的分类及特点　6
1.4.2　Linux设备驱动与整个软硬件系统的关系　7
1.4.3　Linux设备驱动的重点、难点　8
1.5　Linux设备驱动开发环境构建　8
1.5.1　PC上的Linux环境　8
1.5.2　LDD6410开发板　11
1.5.3　工具链安装　13
1.5.4　主机端nfs和tftp服务安装　14
1.5.5　源代码阅读和编辑　14
1.6　设备驱动Hello World：LED驱动　15
1.6.1　无操作系统时的LED驱动　15
1.6.2　Linux下的LED驱动　16
1.7　全书结构　19

第2章　驱动设计的硬件基础　21
2.1　处理器　22
2.1.1　通用处理器　22
2.1.2　数字信号处理器　23
2.2　存储器　25
2.3　接口与总线　29
2.3.1　串口　29
2.3.2　I2C　30
2.3.3　USB　31
2.3.4　以太网接口　33
2.3.5　ISA　34
2.3.6　PCI和cPCI　35
2.4　CPLD和FPGA　38
2.5　原理图分析　41
2.5.1　原理图分析的内容　41
2.5.2　原理图的分析方法　41
2.6　硬件时序分析　43
2.6.1　时序分析的概念　43
2.6.2　典型硬件时序　44
2.7　芯片手册阅读方法　45
2.8　仪器仪表使用　48
2.8.1　万用表　48
2.8.2　示波器　48
2.8.3　逻辑分析仪　50
2.9　总结　52

第3章　Linux内核及内核编程　53
3.1　Linux内核的发展与演变　54
3.2　Linux 2.6内核的特点　55
3.3　Linux内核的组成　56
3.3.1　Linux内核源代码目录结构　56
3.3.2　Linux内核的组成部分　57
3.3.3　Linux内核空间与用户空间　60
3.4　Linux内核的编译及加载　60
3.4.1　Linux内核的编译　60
3.4.2　Kconfig和Makefile　62
3.4.3　Linux内核的引导　69
3.5　Linux下的C编程特点　71
3.5.1　Linux编码风格　71
3.5.2　GNU C与ANSI C　73
3.5.3　do{ }while(0)　77
3.5.4　goto　78
3.6　总结　79

第2篇　Linux设备驱动核心理论

第4章　Linux内核模块　82
4.1　Linux内核模块简介　83
4.2　Linux内核模块程序结构　85
4.3　模块加载函数　85
4.4　模块卸载函数　86
4.5　模块参数　87
4.6　导出符号　88
4.7　模块声明与描述　89
4.8　模块的使用计数　89
4.9　模块的编译　90
4.10　使用模块绕开GPL　91
4.11　总结　91

第5章　Linux文件系统与设备文件系统　92
5.1　Linux文件操作　93
5.1.1　文件操作系统调用　93
5.1.2　C库文件操作　95
5.2　Linux文件系统　97
5.2.1　Linux文件系统目录结构　97
5.2.2　Linux文件系统与设备驱动　98
5.3　devfs设备文件系统　101
5.4　udev设备文件系统　102
5.4.1　udev与devfs的区别　102
5.4.2　sysfs文件系统与Linux设备模型　104
5.4.3　udev的组成　110
5.4.4　udev规则文件　111
5.4.5　创建和配置mdev　113
5.5　LDD6410的SD和NAND文件系统　114
5.6　总结　117

第6章　字符设备驱动　118
6.1　Linux字符设备驱动结构　119
6.1.1　cdev结构体　119
6.1.2　分配和释放设备号　120
6.1.3　file_operations结构体　120
6.1.4　Linux字符设备驱动的组成　122
6.2　globalmem虚拟设备实例描述　124
6.3　globalmem设备驱动　125
6.3.1　头文件、宏及设备结构体　125
6.3.2　加载与卸载设备驱动　126
6.3.3　读写函数　127
6.3.4　seek函数　128
6.3.5　ioctl函数　129
6.3.6　使用文件私有数据　130
6.4　globalmem驱动在用户空间的验证　136
6.5　总结　138

第7章　Linux设备驱动中的并发控制　139
7.1　并发与竞态　140
7.2　中断屏蔽　141
7.3　原子操作　142
7.3.1　整型原子操作　142
7.3.2　位原子操作　142
7.4　自旋锁　143
7.4.1　自旋锁的使用　143
7.4.2　读写自旋锁　145
7.4.3　顺序锁　147
7.4.4　读-拷贝-更新　148
7.5　信号量　152
7.5.1　信号量的使用　152
7.5.2　信号量用于同步　154
7.5.3　完成量用于同步　154
7.5.4　自旋锁vs信号量　155
7.5.5　读写信号量　155
7.6　互斥体　156
7.7　增加并发控制后的globalmem驱动　157
7.8　总结　160

第8章　Linux设备驱动中的阻塞与非阻塞I/O　161
8.1　阻塞与非阻塞I/O　162
8.1.1　等待队列　162
8.1.2　支持阻塞操作的globalfifo设备驱动　166
8.1.3　在用户空间验证globalfifo的读写　171
8.2　轮询操作　172
8.2.1　轮询的概念与作用　172
8.2.2　应用程序中的轮询编程　172
8.2.3　设备驱动中的轮询编程　172
8.3　支持轮询操作的globalfifo驱动　173
8.3.1　在globalfifo驱动中增加轮询操作　173
8.3.2　在用户空间验证globalfifo设备的轮询　174
8.4　总结　175

第9章　Linux设备驱动中的异步通知与异步I/O　176
9.1　异步通知的概念与作用　177
9.2　Linux异步通知编程　177
9.2.1　Linux信号　177
9.2.2　信号的接收　179
9.2.3　信号的释放　180
9.3　支持异步通知的globalfifo驱动　182
9.3.1　在globalfifo驱动中增加异步通知　182
9.3.2　在用户空间验证globalfifo的异步通知　184
9.4　Linux 2.6异步I/O　185
9.4.1　AIO概念与GNU C库函数　185
9.4.2　使用信号作为AIO的通知　188
9.4.3　使用回调函数作为AIO的通知　189
9.4.4　AIO与设备驱动　190
9.5　总结　192

第10章　中断与时钟　193
10.1　中断与定时器　194
10.2　Linux中断处理程序架构　195
10.3　Linux中断编程　196
10.3.1　申请和释放中断　196
10.3.2　使能和屏蔽中断　197
10.3.3　底半部机制　197
10.3.4　实例：S3C6410实时钟中断　200
10.4　中断共享　202
10.5　内核定时器　203
10.5.1　内核定时器编程　203
10.5.2　内核中延迟的工作delayed_work　205
10.5.3　实例：秒字符设备　206
10.6　内核延时　210
10.6.1　短延迟　210
10.6.2　长延迟　210
10.6.3　睡着延迟　211
10.7　总结　212

第11章　内存与I/O访问　213
11.1　CPU与内存和I/O　214
11.1.1　内存空间与I/O空间　214
11.1.2　内存管理单元MMU　215
11.2　Linux内存管理　218
11.3　内存存取　220
11.3.1　用户空间内存动态申请　220
11.3.2　内核空间内存动态申请　221
11.3.3　虚拟地址与物理地址关系　224
11.4　设备I/O端口和I/O内存的访问　225
11.4.1　Linux I/O端口和I/O内存访问接口　225
11.4.2　申请与释放设备I/O端口和I/O内存　226
11.4.3　设备I/O端口和I/O内存访问流程　227
11.4.4　将设备地址映射到用户空间　228
11.5　I/O内存静态映射　233
11.6　DMA　236
11.6.1　DMA与Cache一致性　236
11.6.2　Linux下的DMA编程　237
11.7　总结　241

第12章　工程中的Linux设备驱动　242
12.1　platform设备驱动　243
12.1.1　platform总线、设备与驱动　243
12.1.2　将globalfifo作为platform设备　244
12.1.3　platform设备资源和数据　246
12.2　设备驱动的分层思想　248
12.2.1　设备驱动核心层和例化　248
12.2.2　输入设备驱动　249
12.2.3　RTC设备驱动　254
12.3　主机驱动与外设驱动分离思想　255
12.3.1　主机、外设驱动分离的意义　255
12.3.2　Linux SPI主机和设备驱动　256
12.4　设备驱动中的电源管理　260
12.5　misc设备驱动　262
12.6　基于sysfs的设备驱动　263
12.7　Linux设备驱动的固件加载　265
12.8　Android设备驱动　266
12.9　总结　269

第3篇　Linux设备驱动实例

第13章　Linux块设备驱动　272
13.1　块设备的I/O操作特点　273
13.2　Linux块设备驱动结构　273
13.2.1　block_device_operations结构体　273
13.2.2　gendisk结构体　274
13.2.3　request与bio结构体　276
13.2.4　块设备驱动注册与注销　285
13.3　Linux块设备驱动的模块加载与卸载　286
13.4　块设备的打开与释放　288
13.5　块设备驱动的ioctl函数　288
13.6　块设备驱动的I/O请求处理　289
13.6.1　使用请求队列　289
13.6.2　不使用请求队列　291
13.7　实例1：vmem_disk驱动　292
13.7.1　vmem_disk的硬件原理　292
13.7.2　vmem_disk驱动模块的加载与卸载　293
13.7.3　vmem_disk设备驱动block_device_operations及成员函数　296
13.7.4　vmem_disk I/O请求处理　298
13.8　实例2：IDE硬盘设备驱动　300
13.9　总结　303

第14章　Linux终端设备驱动　304
14.1　终端设备　305
14.2　终端设备驱动结构　307
14.3　终端设备驱动初始化与释放　311
14.3.1　模块加载与卸载函数　311
14.3.2　打开与关闭函数　312
14.4　数据发送和接收　313
14.5　TTY线路设置　316
14.5.1　线路设置用户空间接口　316
14.5.2　tty驱动set_termios函数　317
14.5.3　tty驱动的tiocmget和tiocmset函数　318
14.5.4　tty驱动ioctl函数　319
14.6　UART设备驱动　320
14.7　printk和early_printk console驱动　325
14.8　实例：S3C6410串口与console驱动　328
14.8.1　S3C6410串口硬件描述　328
14.8.2　S3C6410串口UART驱动　330
14.8.3　S3C6410串口console驱动　331
14.9　总结　332

第15章　Linux的I2C核心、总线与设备驱动　333
15.1　Linux的I2C体系结构　334
15.2　Linux I2C核心　339
15.3　Linux I2C总线驱动　341
15.3.1　I2C适配器驱动加载与卸载　341
15.3.2　I2C总线通信方法　342
15.4　Linux I2C设备驱动　344
15.4.1　Linux I2C设备驱动的模块加载与卸载　344
15.4.2　Linux I2C设备驱动的数据传输　344
15.4.3　Linux的i2c-dev.c文件分析　345
15.5　S3C6410 I2C总线驱动实例　349
15.5.1　S3C6410 I2C控制器硬件描述　349
15.5.2　S3C6410 I2C总线驱动总体分析　349
15.5.3　S3C6410 I2C适配器驱动的模块加载与卸载　350
15.5.4　S3C6410 I2C总线通信方法　354
15.6　AT24XX EEPROM的I2C设备驱动实例　359
15.7　总结　362

第16章　Linux网络设备驱动　363
16.1　Linux网络设备驱动的结构　364
16.1.1　网络协议接口层　364
16.1.2　网络设备接口层　366
16.1.3　设备驱动功能层　369
16.1.4　网络设备与媒介层　369
16.2　网络设备驱动的注册与注销　369
16.3　网络设备的初始化　371
16.4　网络设备的打开与释放　372
16.5　数据发送流程　373
16.6　数据接收流程　374
16.7　网络连接状态　377
16.8　参数设置和统计数据　378
16.9　DM9000网卡设备驱动实例　381
16.9.1　DM9000网卡硬件描述　381
16.9.2　DM9000网卡驱动设计分析　383
16.10　总结　387

第17章　Linux音频设备驱动　388
17.1　数字音频设备　389
17.2　音频设备硬件接口　390
17.2.1　PCM接口　390
17.2.2　IIS接口　390
17.2.3　AC'97接口　390
17.3　Linux OSS音频设备驱动　391
17.3.1　OSS驱动的组成　391
17.3.2　mixer接口　392
17.3.3　dsp接口　393
17.3.4　OSS用户空间编程　394
17.4　Linux ALSA音频设备驱动　399
17.4.1　ALSA的组成　399
17.4.2　card和组件管理　400
17.4.3　PCM设备　402
17.4.4　控制接口　412
17.4.5　AC97 API接口　416
17.4.6　ALSA用户空间编程　418
17.5　Linux ASoC音频设备驱动　423
17.5.1　ASoC驱动的组成　423
17.5.2　ASoC Codec驱动　423
17.5.3　ASoC平台驱动　426
17.5.4　ASoC板驱动　429
17.6　S3C6410+WM9714 ASoC驱动实例　430
17.7　总结　439

第18章　LCD设备驱动　440
18.1　LCD硬件原理　441
18.2　帧缓冲　443
18.2.1　帧缓冲的概念　443
18.2.2　显示缓冲区与显示点　443
18.2.3　Linux帧缓冲相关数据结构与函数　444
18.3　Linux帧缓冲设备驱动结构　450
18.4　帧缓冲设备驱动的模块加载与卸载函数　450
18.5　帧缓冲设备显示缓冲区的申请与释放　452
18.6　帧缓冲设备的参数设置　453
18.6.1　定时参数　453
18.6.2　像素时钟　454
18.6.3　颜色位域　454
18.6.4　固定参数　455
18.7　帧缓冲设备驱动的fb_ops成员函数　455
18.8　LCD设备驱动的读写、mmap和ioctl函数　456
18.9　帧缓冲设备的用户空间访问　461
18.10　Linux图形用户界面　463
18.10.1　Qt-X11/QtEmbedded/Qtopia　463
18.10.2　Microwindows/Nano-X　467
18.10.3　MiniGUI　469
18.10.4　Android　471
18.11　实例：S3C6410 LCD设备驱动　474
18.12　总结　478

第19章　Flash设备驱动　479
19.1　Linux Flash驱动结构　480
19.1.1　Linux MTD系统层次　480
19.1.2　Linux MTD系统接口　480
19.1.3　MTD用户空间编程　485
19.2　NOR Flash驱动　488
19.3　NAND Flash驱动　491
19.4　NOR Flash驱动实例：S3C6410外围的NOR Flash驱动　496
19.5　NAND Flash驱动实例：S3C6410外围的NAND Flash驱动　497
19.5.1　S3C6410 NAND控制器硬件描述　497
19.5.2　S3C6410 nand_chip初始化与NAND探测　498
19.6　Flash文件系统的建立　500
19.6.1　Flash转换层　500
19.6.2　CramFS　501
19.6.3　JFFS/JFFS2　501
19.6.4　YAFFS/YAFFS2　502
19.6.5　UBI/UBIFS　505
19.7　总结　506

第20章　USB主机与设备驱动　507
20.1　Linux USB驱动层次　508
20.1.1　主机侧与设备侧USB驱动　508
20.1.2　设备、配置、接口、端点　509
20.2　USB主机控制器驱动　512
20.2.1　USB主机控制器驱动的整体结构　512
20.2.2　实例：S3C6410 USB 1.1主机驱动　516
20.3　USB设备驱动　518
20.3.1　USB设备驱动整体结构　518
20.3.2　USB请求块(URB)　523
20.3.3　探测和断开函数　527
20.3.4　USB骨架程序　528
20.3.5　实例：USB键盘驱动　534
20.4　USB UDC与gadget驱动　536
20.4.1  UDC和gadget驱动关键数据结构与API　536
20.4.2　实例：S3C6410 USB 2.0的UDC驱动　540
20.4.3　实例：file storage gadget驱动　542
20.5　USB OTG驱动　544
20.6　总结　545

第21章　PCI设备驱动　547
21.1　PCI总线与配置空间　548
21.1.1　PCI总线的Linux描述　548
21.1.2　PCI设备的Linux描述　550
21.1.3　PCI配置空间访问　551
21.1.4　PCI DMA相关的API　555
21.1.5　PCI 设备驱动其他常用API　555
21.2　PCI设备驱动结构　556
21.2.1　PCI设备驱动的组成　556
21.2.2　实例：PCI骨架程序　560
21.3　总结　562

第4篇　Linux设备驱动调试、移植

第22章　Linux设备驱动的调试　564
22.1　Linux开发环境建设　565
22.1.1　实验室建设　565
22.1.2　工具链　566
22.1.3　串口工具　567
22.2　GDB调试器用法　570
22.2.1　GDB基本用法　570
22.2.2　DDD图形界面调试工具　578
22.3　Linux内核调试　580
22.4　内核打印信息――printk()　581
22.5　使用/proc　582
22.6　Oops　586
22.7　监视工具　588
22.8　内核调试器　589
22.8.1　kcore　589
22.8.2　KDB　592
22.8.3　KGDB　594
22.9　使用仿真器调试内核　595
22.10　应用程序调试　596
22.11　Linux性能监控与调优工具　598
22.12　总结　601

第23章　Linux设备驱动的移植　602
23.1　编写可移植的设备驱动　603
23.1.1　可移植的数据类型　603
23.1.2　结构体对界　604
23.1.3　Little Endian与Big Endian　605
23.1.4　内存页面大小　605
23.2　巧用同类设备驱动　606
23.2.1　巧用demo板驱动　606
23.2.2　巧用类似芯片的驱动程序　606
23.2.3　借用芯片厂商的范例程序　609
23.3　从Linux 2.4移植设备驱动到Linux 2.6　610
23.4　Linux与其他操作系统之间的驱动移植　618
23.5　Linux内核的移植　626
23.6　总结　630

参考文献　631
