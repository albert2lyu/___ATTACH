
第1章　Android底层开发基础	1
1.1  什么是驱动	1
1.1.1  驱动程序的魅力	1
1.1.2  手机中的驱动程序	2
1.2  开源还是不开源的问题	2
1.2.1  雾里看花的开源	2
1.2.2  从为什么选择Java谈为什么不
开源驱动程序	3
1.2.3  对驱动开发者来说是一把双刃剑	4
1.3  Android和Linux	4
1.3.1  Linux简介	4
1.3.2  Android和Linux的关系	5
1.4  简析Linux内核	7
1.4.1  内核的体系结构	7
1.4.2  和Android密切相关的Linux
内核知识	9
1.5  分析Linux内核源代码很有必要	13
1.5.1  源代码目录结构	14
1.5.2  Linux 3.10的特性	16
1.5.3  浏览源代码的工具	17
1.5.4  为什么用汇编语言编写内核代码	17
1.5.5  Linux内核的显著特性	18
1.5.6  学习Linux内核的方法	26
第2章　分析Android源代码	31
2.1  搭建Linux开发环境和工具	31
2.1.1  搭建Linux开发环境	31
2.1.2  设置环境变量	32
2.1.3  安装编译工具	32
2.2  获取Android源代码	33
2.3  分析并编译Android源代码	35
2.3.1  Android源代码的结构	35
2.3.2  编译Android源代码	40
2.3.3  运行Android源代码	42
2.3.4  实践演练――演示编译Android
程序的两种方法	43
2.4  编译Android Kernel	46
2.4.1  获取Goldfish内核代码	47
2.4.2  获取MSM内核代码	49
2.4.3  获取OMAP内核代码	49
2.4.4  编译Android的Linux内核	50
2.5  运行模拟器	51
2.5.1  Linux环境下运行模拟器的方法	52
2.5.2  模拟器辅助工具――adb	53
第3章　驱动需要移植	56
3.1  驱动开发需要做的工作	56
3.2  Android移植	58
3.2.1  移植的任务	59
3.2.2  移植的内容	59
3.2.3  驱动开发的任务	60
3.3  Android对Linux的改造	60
3.3.1  Android对Linux内核文件的改动	61
3.3.2  为Android构建Linux的操作系统	62
3.4  内核空间和用户空间接口是一个媒介	63
3.4.1  内核空间和用户空间的相互作用	63
3.4.2  系统和硬件之间的交互	63
3.4.3  使用Relay实现内核到用户空
间的数据传输	65
3.5  三类驱动程序	68
3.5.1  字符设备驱动程序	68
3.5.2  块设备驱动程序	76
3.5.3  网络设备驱动程序	80
第4章　HAL层深入分析	81
4.1  认识HAL层	81
4.1.1  HAL层的发展	81
4.1.2  过去和现在的区别	83
4.2  分析HAL层源代码	83
4.2.1  分析HAL moudle	83
4.2.2  分析mokoid工程	87
4.3  总结HAL层的使用方法	95
4.4  传感器在HAL层的表现	97
4.4.1  HAL层的Sensor代码	98
4.4.2  总结Sensor编程的流程	99
4.4.3  分析Sensor源代码看Android API 
与硬件平台的衔接	100
4.5  移植总结	110
4.5.1  移植各个Android部件的方式	110
4.5.2  移植技巧之一――不得不说的
辅助工作	111
4.6  开发一个硬件驱动程序	117
4.6.1  源代码文件wuming.h和
wuming.c	117
4.6.2  编译配置处理	123
4.6.3  修改配置文件	124
4.6.4  验证驱动程序	125
第5章　分析Goldfish内核系统	127
5.1  Android专有驱动介绍	127
5.2  Goldfish基础	128
5.3  Android专用驱动简介	130
5.3.1  Logger驱动介绍	130
5.3.2  Low Memory Killer组件介绍	130
5.3.3  Timed Output驱动介绍	131
5.3.4  Timed Gpio驱动介绍	131
5.3.5  Ram Console驱动介绍	132
5.4  Ashmem驱动介绍	133
5.5  Pmem驱动介绍	133
5.6  Alarm驱动程序	134
5.7  USB Gadget驱动程序	134
5.8  Paranoid驱动介绍	135
5.9  Goldfish的设备驱动	136
第6章　MSM内核和驱动解析	139
6.1  MSM基础	139
6.1.1  常见MSM处理器产品	139
6.1.2  Snapdragon内核介绍	140
6.2  移植MSM内核简介	141
6.3  移植MSM	143
6.3.1  Makefile文件	143
6.3.2  驱动和组件	144
6.3.3  设备驱动	146
6.3.4  高通特有的组件	148
第7章　OMAP内核和驱动解析	151
7.1  OMAP基础	151
7.1.1  OMAP简析	151
7.1.2  常见OMAP处理器产品	151
7.1.3  开发平台	152
7.2  OMAP内核	152
7.3  移植OMAP体系结构	154
7.3.1  移植OMAP平台	154
7.3.2  移植OMAP处理器	157
7.4  移植Android专用驱动和组件	161
7.5  OMAP的设备驱动	162
7.5.1  显示驱动程序	162
7.5.2  I2C总线驱动程序	162
7.5.3  摄像头和视频输出驱动程序	164
7.5.4  触摸屏和键盘驱动程序	165
7.5.5  实时时钟驱动程序	166
7.5.6  音频驱动程序	166
7.5.7  蓝牙驱动程序	166
第8章　显示系统驱动应用	167
8.1  显示系统介绍	167
8.2  分析内核层	168
8.2.1  分析接口文件fb.h	168
8.2.2  分析内核实现文件fbmem.c	171
8.3  分析硬件抽象层	195
8.3.1  分析头文件	195
8.3.2  分析硬件帧缓冲区	197
8.3.3  实现缓冲区的分配	199
8.3.4  显示缓冲映射	200
8.3.5  分析管理库文件LayerBuffer.cpp	201
8.4  分析显示系统的驱动程序	202
8.4.1  Goldfish中的FrameBuffer驱
动程序	203
8.4.2  使用Gralloc模块的驱动程序	205
8.4.3  分析MSM高通处理器中的显
示驱动实现	215
8.4.4  分析OMAP处理器中的显示
驱动实现	225
第9章　输入系统驱动应用	228
9.1  输入系统介绍	228
9.1.1  Android输入系统结构元素介绍	228
9.1.2  移植Android输入系统时的工作	229
9.2  分析Input（输入）系统驱动	230
9.2.1  分析头文件	230
9.2.2  分析核心文件input.c	234
9.2.3  分析event机制	249
9.3  分析硬件抽象层	251
9.3.1  分析文件KeycodeLabels.h	252
9.3.2  分析文件KeyCharacterMap.h	256
9.3.3  分析Kl格式文件	257
9.3.4  分析kcm格式文件	258
9.3.5  分析文件EventHub.cpp	258
第10章　振动器系统驱动	263
10.1  振动器系统结构	263
10.2  分析硬件抽象层	265
10.3  分析JNI层部分	266
10.4  分析Java层部分	267
10.5  实现移植工作	271
10.5.1  移植振动器驱动程序	271
10.5.2  实现硬件抽象层	271
10.6  在MSM平台实现振动器驱动	272
第11章　音频系统驱动	276
11.1  音频系统结构	276
11.2  分析音频系统的层次	277
11.2.1  层次说明	277
11.2.2  Media库中的Audio框架	278
11.2.3  本地代码	280
11.2.4  分析JNI代码	283
11.2.5  Java层代码简介	284
11.3  移植Audio系统的工作	285
11.3.1  我们的工作	285
11.3.2  分析硬件抽象层	285
11.3.3  分析AudioFlinger中的Audio
硬件抽象层的实现	287
11.3.4  真正实现Audio硬件抽象层	293
11.4  在MSM平台实现Audio驱动系统	293
11.4.1  实现Audio驱动程序	293
11.4.2  实现硬件抽象层	294
第12章　视频输出系统驱动	299
12.1  视频输出系统结构	299
12.2  需要移植的部分	301
12.3  分析硬件抽象层	301
12.3.1  Overlay系统硬件抽象层的接口	301
12.3.2  实现Overlay系统的硬件抽象层	304
12.3.3  实现接口	305
12.4  实现Overlay硬件抽象层	306
12.5  在OMAP平台实现Overlay系统	307
12.5.1  实现输出视频驱动程序	307
12.5.2  实现Overlay硬件抽象层	309
12.6  系统层调用Overlay HAL的架构	314
12.6.1  调用Overlay HAL的架构的
流程	314
12.6.2  S3C6410 Android Overlay的
测试代码	317
第13章　OpenMax多媒体框架	320
13.1  OpenMax基本层次结构	320
13.2  分析OpenMax框架构成	321
13.2.1  OpenMax总体层次结构	321
13.2.2  OpenMax IL层的结构	322
13.2.3  Android中的OpenMax	325
13.3  实现OpenMax IL层接口	325
13.3.1  OpenMax IL层的接口	325
13.3.2  在OpenMax IL层中需要做什么	331
13.3.3  研究Android中的OpenMax
适配层	332
13.4  在OMAP平台实现OpenMax IL	334
13.4.1  实现文件	334
13.4.2  分析TI OpenMax IL的核心	335
13.4.3  实现TI OpenMax IL组件实例	338
第14章　多媒体插件框架	343
14.1  Android多媒体插件	343
14.2  需要移植的内容	344
14.3  OpenCore引擎	345
14.3.1  OpenCore层次结构	345
14.3.2  OpenCore代码结构	346
14.3.3  OpenCore编译结构	347
14.3.4  OpenCore OSCL	351
14.3.5  实现OpenCore中的OpenMax
部分	353
14.3.6  OpenCore的扩展	366
14.4  Stagefright引擎	371
14.4.1  Stagefright代码结构	372
14.4.2  Stagefright实现OpenMax接口	372
14.4.3  Video Buffer传输流程	376
第15章　传感器系统	381
15.1  传感器系统的结构	381
15.2  分析需要移植的内容	383
15.2.1  移植驱动程序	383
15.2.2  移植硬件抽象层	384
15.2.3  实现上层部分	385
15.3  在模拟器中实现传感器驱动	389
第16章　照相机系统	395
16.1  Camera系统的结构	395
16.2  分析需要移植的内容	397
16.3  移植和调试	398
16.3.1  V4L2驱动程序	398
16.3.2  硬件抽象层	405
16.4  实现Camera系统的硬件抽象层	409
16.4.1  Java程序部分	409
16.4.2  Camera的Java本地调用部分	410
16.4.3  Camera的本地库libui.so	411
16.4.4  Camera服务libcameraservice.so	412
16.5  在MSM平台实现Camera驱动系统	416
16.6  在OMAP平台实现Camera驱动系统	419
第17章　Wi-Fi系统、蓝牙系统和
GPS系统	421
17.1  Wi-Fi系统	421
17.1.1  Wi-Fi系统的结构	421
17.1.2  需要移植的内容	423
17.1.3  移植和调试	423
17.1.4  OMAP平台实现Wi-Fi	430
17.1.5  配置Wi-Fi的流程	432
17.1.6  具体演练――在Android下
实现Ethernet	435
17.2  蓝牙系统	436
17.2.1  蓝牙系统的结构	437
17.2.2  需要移植的内容	438
17.2.3  具体移植	439
17.2.4  MSM平台的蓝牙驱动	441
17.3  定位系统	443
17.3.1  定位系统的结构	443
17.3.2  分析需要移植的内容	445
17.3.3  分析驱动程序	445
17.3.4  分析硬件抽象层	445
17.3.5  分析上层应用部分	448
第18章　电话系统	457
18.1  电话系统基础	457
18.1.1  电话系统简介	457
18.1.2  电话系统结构	459
18.2  需要移植的内容	460
18.3  移植和调试	460
18.3.1  驱动程序	461
18.3.2  RIL接口	462
18.4  电话系统实现流程分析	465
18.4.1  初始启动流程	465
18.4.2  request流程	467
18.4.3  response流程	470
第19章　分析时钟系统驱动	472
19.1  Alarm系统基础	472
19.1.1  Alarm层次结构介绍	472
19.1.2  我们需要移植的内容	474
19.2  分析RTC驱动程序	474
19.3  分析Alarm驱动程序	475
19.3.1  分析文件android_alarm.h	475
19.3.2  分析文件alarm.c	476
19.3.3  分析文件alarm-dev.c	488
19.4  分析JNI层	497
19.5  分析Java层	498
19.5.1  分析AlarmManagerService类	499
19.5.2  分析AlarmManager类	508
19.6  模拟器环境的具体实现	509
第20章　分析USB Gadget驱动	511
20.1  分析Linux内核的USB驱动程序	511
20.1.1  USB设备基础	511
20.1.2  分析USB 和sysfs的联系	516
20.1.3  分析urb通信方式	518
20.1.4  分析USB驱动的例程	524
20.2  分析USB Gadget驱动	536
20.2.1  分析软件结构	536
20.2.2  层次整合	546
20.2.3  USB设备枚举	557
第21章　其他系统	573
21.1  Lights光系统	573
21.1.1  Lights光系统的结构	573
21.1.2  需要移植的内容	574
21.1.3  移植和调试	575
21.1.4  MSM平台实现光系统	577
21.2  Battery电池系统	577
21.2.1  Battery系统的结构	578
21.2.2  需要移植的内容	579
21.2.3  移植和调试	579
21.2.4  在模拟器中实现电池系统	582
