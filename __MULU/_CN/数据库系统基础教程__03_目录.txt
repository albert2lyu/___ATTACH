
出版者的话
译者序
前言
第1章　数据库系统世界 1
1.1　数据库系统的发展 1
1.1.1　早期的数据库管理系统 1
1.1.2　关系数据库系统 2
1.1.3　越来越小的系统 2
1.1.4　越来越大的系统 2
1.1.5　信息集成 3
1.2　数据库管理系统概述 3
1.2.1　数据定义语言命令 3
1.2.2　查询处理概述 4
1.2.3　存储器和缓冲区管理器 5
1.2.4　事务处理 5
1.2.5　查询处理器 6
1.3　本书概述 6
1.4　参考文献 7
第一部分　关系数据库模型
第2章　关系数据模型 9
2.1　数据模型概述 9
2.1.1　什么是数据模型 9
2.1.2　一些重要的数据模型 9
2.1.3　关系模型简介 10
2.1.4　半结构化模型简介 10
2.1.5　其他数据模型 11
2.1.6　几种建模方法的比较 11
2.2　关系模型基础 12
2.2.1　属性 12
2.2.2　模式 12
2.2.3　元组 12
2.2.4　域 12
2.2.5　关系的等价描述 13
2.2.6　关系实例 13
2.2.7　关系上的键 13
2.2.8　数据库模式示例 14
2.2.9　习题 15
2.3　在SQL中定义关系模式 16
2.3.1　SQL中的关系 16
2.3.2　数据类型 16
2.3.3　简单的表定义 17
2.3.4　修改关系模式 18
2.3.5　默认值 18
2.3.6　键的声明 19
2.3.7　习题 20
2.4　代数查询语言 21
2.4.1　为什么需要一种专门的查询语言 21
2.4.2　什么是代数 21
2.4.3　关系代数概述 21
2.4.4　关系上的集合操作 21
2.4.5　投影 23
2.4.6　选择 23
2.4.7　笛卡儿积 24
2.4.8　自然连接 24
2.4.9　q连接 25
2.4.10　组合操作构成查询 26
2.4.11　命名和重命名 27
2.4.12　操作之间的联系 27
2.4.13　代数表达式的线性符号 28
2.4.14　习题 29
2.5　关系上的约束 32
2.5.1　作为约束语言的关系代数 32
2.5.2　引用完整性约束 33
2.5.3　键约束 33
2.5.4　其他约束举例 34
2.5.5　习题 35
2.6　小结 35
2.7　参考文献 36
第3章　关系数据库设计理论 37
3.1　函数依赖 37
3.1.1　函数依赖的定义 37
3.1.2　关系的键 38
3.1.3　超键 39
3.1.4　习题 40
3.2　函数依赖的规则 40
3.2.1　函数依赖的推导 40
3.2.2　分解/结合规则 40
3.2.3　平凡函数依赖 41
3.2.4　计算属性的闭包 42
3.2.5　闭包算法为何有效 43
3.2.6　传递规则 44
3.2.7　函数依赖的闭包集合 45
3.2.8　投影函数依赖 45
3.2.9　习题 47
3.3　关系数据库模式设计 48
3.3.1　异常 48
3.3.2　分解关系 49
3.3.3　Boyce-Codd范式 50
3.3.4　分解为BCNF 50
3.3.5　习题 52
3.4　分解的优劣 53
3.4.1　从分解中恢复信息 53
3.4.2　无损连接的chase检验 55
3.4.3　为什么chase检验有效 56
3.4.4　依赖的保持 57
3.4.5　习题 58
3.5　第三范式 58
3.5.1　第三范式的定义 59
3.5.2　3NF模式综合算法 59
3.5.3　为什么3NF综合算法有效 60
3.5.4　习题 60
3.6　多值依赖 61
3.6.1　属性独立及随之产生的冗余 61
3.6.2　多值依赖的定义 61
3.6.3　多值依赖的推导 62
3.6.4　第四范式 64
3.6.5　分解为第四范式 64
3.6.6　范式间的联系 65
3.6.7　习题 65
3.7　MVD的发现算法 66
3.7.1　闭包和chase 66
3.7.2　将chase扩展到MVD 67
3.7.3　chase为何对MVD有效 69
3.7.4　投影MVD 69
3.7.5　习题 70
3.8　小结 70
3.9　参考文献 71
第4章　高级数据库模型 73
4.1　E/R模型 73
4.1.1　实体集 73
4.1.2　属性 74
4.1.3　联系 74
4.1.4　实体-联系图 74
4.1.5　E/R图实例 75
4.1.6　二元E/R联系的多样性 75
4.1.7　多路联系 76
4.1.8　联系中的角色 77
4.1.9　联系的属性 78
4.1.10　多路联系到二元联系的转换 79
4.1.11　E/R模型中的子类 80
4.1.12　习题 81
4.2　设计原则 82
4.2.1　忠实性 82
4.2.2　避免冗余 83
4.2.3　简单性　 83
4.2.4　选择正确的联系 83
4.2.5　选择正确的元素种类 84
4.2.6　习题 86
4.3　E/R模型中的约束 87
4.3.1　E/R模型中的键 87
4.3.2　E/R模型中键的表示 87
4.3.3　引用完整性 88
4.3.4　度约束 89
4.3.5　习题 89
4.4　弱实体集 89
4.4.1　弱实体集的来源 89
4.4.2　弱实体集的要求 90
4.4.3　弱实体集的符号 91
4.4.4　习题 91
4.5　从E/R图到关系设计 92
4.5.1　实体集到关系的转化 92
4.5.2　E/R联系到关系的转化 92
4.5.3　关系组合 94
4.5.4　处理弱实体集 95
4.5.5　习题 96
4.6　子类结构到关系的转化 97
4.6.1　E/R方式转化 97
4.6.2　面向对象方法 98
4.6.3　使用空值组合关系 99
4.6.4　各种方法的比较 99
4.6.5　习题 100
4.7　统一建模语言 101
4.7.1　UML类 101
4.7.2　UML类的键 101
4.7.3　关联 101
4.7.4　自关联 102
4.7.5　关联类 103
4.7.6　UML中的子类 103
4.7.7　聚集与组合 104
4.7.8　习题 105
4.8　UML图到关系的转化 105
4.8.1　UML到关系的基础知识 105
4.8.2　从UML子类到关系 106
4.8.3　从聚集与组合到关系 106
4.8.4　UML与弱实体集的类比 107
4.8.5　习题 108
4.9　对象定义语言 108
4.9.1　类声明 108
4.9.2　ODL中的属性 108
4.9.3　ODL中的联系 109
4.9.4　反向联系 109
4.9.5　联系的多重性 110
4.9.6　ODL中的类型 110
4.9.7　ODL中的子类 112
4.9.8　在ODL中声明键 113
4.9.9　习题 113
4.10　从ODL设计到关系设计 114
4.10.1　从ODL类到关系 114
4.10.2　类中的复杂属性 114
4.10.3　值集合类型属性的表示 115
4.10.4　其他类型构建器的表示 116
4.10.5　ODL中联系的表示 117
4.10.6　习题 117
4.11　小结 118
4.12　参考文献 119
第二部分　关系数据库程序设计
第5章　代数和逻辑查询语言 121
5.1　包上的关系操作 121
5.1.1　为什么采用包 121
5.1.2　包的并、交、差 122
5.1.3　包上的投影操作 123
5.1.4　包上的选择操作 123
5.1.5　包的笛卡儿积 124
5.1.6　包的连接 124
5.1.7　习题 125
5.2　关系代数的扩展操作符 125
5.2.1　消除重复 126
5.2.2　聚集操作符 126
5.2.3　分组 127
5.2.4　分组操作符 127
5.2.5　扩展的投影操作符 128
5.2.6　排序操作符 129
5.2.7　外连接 129
5.2.8　习题 130
5.3　关系逻辑 131
5.3.1　谓词和原子 131
5.3.2　算术原子 131
5.3.3　Datalog规则和查询 132
5.3.4　Datalog规则的意义 133
5.3.5　扩展谓词和内涵谓词 134
5.3.6　Datalog规则应用于包 135
5.3.7　习题 136
5.4　关系代数与Datalog 136
5.4.1　布尔操作 136
5.4.2　投影 137
5.4.3　选择 137
5.4.4　积 138
5.4.5　连接 139
5.4.6　用Datalog模拟多重操作 139
5.4.7　Datalog与关系代数的比较 140
5.4.8　习题 141
5.5　小结 141
5.6　参考文献 142
第6章　数据库语言SQL 143
6.1　SQL中的简单查询 143
6.1.1　SQL中的投影 145
6.1.2　SQL中的选择 146
6.1.3　字符串比较 147
6.1.4　SQL中的模式匹配 147
6.1.5　日期和时间 148
6.1.6　空值和涉及空值的比较 149
6.1.7　布尔值UNKNOWN 149
6.1.8　输出排序 151
6.1.9　习题 151
6.2　多关系查询 152
6.2.1　SQL中的积和连接 153
6.2.2　消除属性歧义 153
6.2.3　元组变量 154
6.2.4　多关系查询的解释 155
6.2.5　查询的并、交、差 156
6.2.6　习题 157
6.3　子查询 158
6.3.1　产生标量值的子查询 159
6.3.2　关系的条件表达式 160
6.3.3　元组的条件表达式 160
6.3.4　关联子查询 161
6.3.5　FROM子句中的子查询 162
6.3.6　SQL的连接表达式 163
6.3.7　自然连接 164
6.3.8　外连接 164
6.3.9　习题 165
6.4　全关系操作 167
6.4.1　消除重复 167
6.4.2　并、交、差中的重复 168
6.4.3　SQL中的分组和聚集 168
6.4.4　聚集操作符 168
6.4.5　分组 169
6.4.6　分组、聚集和空值 170
6.4.7　HAVING子句 171
6.4.8　习题 171
6.5　数据库更新 172
6.5.1　插入 172
6.5.2　删除 174
6.5.3　修改 174
6.5.4　习题 175
6.6　SQL中的事务 175
6.6.1　可串行化 175
6.6.2　原子性 177
6.6.3　事务 177
6.6.4　只读事务 178
6.6.5　读脏数据 179
6.6.6　其他隔离层次 180
6.6.7　习题 181
6.7　小结 182
6.8　参考文献 183
第7章　约束与触发器 184
7.1　键和外键 184
7.1.1　外键约束声明 184
7.1.2　维护引用完整性 185
7.1.3　延迟约束检查 186
7.1.4　习题 188
7.2　属性和元组上的约束 188
7.2.1　非空值约束 189
7.2.2　基于属性的CHECK约束 189
7.2.3　基于元组的CHECK约束 190
7.2.4　基于元组和基于属性的约束的比较 191
7.2.5　习题 191
7.3　修改约束 192
7.3.1　给约束命名 192
7.3.2　修改表上的约束 193
7.3.3　习题 193
7.4　断言 194
7.4.1　创建断言 194
7.4.2　使用断言 194
7.4.3　习题 195
7.5　触发器 196
7.5.1　SQL中的触发器 196
7.5.2　触发器设计的选项 197
7.5.3　习题 199
7.6　小结 200
7.7　参考文献 201
第8章　视图与索引 202
8.1　虚拟视图 202
8.1.1　视图定义 202
8.1.2　视图查询 203
8.1.3　属性重命名 203
8.1.4　习题 204
8.2　视图更新 204
8.2.1　视图删除 204
8.2.2　可更新视图 204
8.2.3　视图中的替换触发器 206
8.2.4　习题 207
8.3　SQL中的索引 207
8.3.1　建立索引的动机 208
8.3.2　索引的声明 208
8.3.3　习题 209
8.4　索引的选择 209
8.4.1　简单代价模型 209
8.4.2　一些有用的索引 209
8.4.3　计算最佳索引 211
8.4.4　索引的自动选择 213
8.4.5　习题 213
8.5　物化视图 214
8.5.1　物化视图的维护 214
8.5.2　物化视图的定期维护 215
8.5.3　利用物化视图重写查询 216
8.5.4　物化视图的自动创建 217
8.5.5　习题 218
8.6　小结 218
8.7　参考文献 219
第9章　服务器环境下的SQL 220
9.1　三层体系结构 220
9.1.1　Web服务器层 220
9.1.2　应用层 221
9.1.3　数据库层 222
9.2　SQL环境 222
9.2.1　环境 222
9.2.2　模式 223
9.2.3　目录 223
9.2.4　SQL环境中的客户和服务器 224
9.2.5　连接 224
9.2.6　会话 225
9.2.7　模块 225
9.3　SQL/宿主语言接口 225
9.3.1　阻抗不匹配问题 226
9.3.2　SQL与宿主语言连接 227
9.3.3　DECLARE节 227
9.3.4　使用共享变量 227
9.3.5　单元组选择语句 228
9.3.6　游标 229
9.3.7　游标更新 231
9.3.8　避免并发修改 231
9.3.9　动态SQL 232
9.3.10　习题 233
9.4　存储过程 234
9.4.1　创建PSM函数和过程 234
9.4.2　PSM中的简单语句格式 234
9.4.3　分支语句 235
9.4.4　PSM中的查询 236
9.4.5　PSM中的循环 237
9.4.6　for循环 238
9.4.7　PSM中的异常处理 239
9.4.8　使用PSM函数和过程 241
9.4.9　习题 241
9.5　使用调用层接口 242
9.5.1　SQL/CLI简介 242
9.5.2　进程语句 244
9.5.3　从查询结果中取数据 244
9.5.4　向查询传递参数 246
9.5.5　习题 247
9.6　JDBC 247
9.6.1　JDBC简介 247
9.6.2　JDBC中的创建语句 248
9.6.3　JDBC中的游标操作 249
9.6.4　参数传递 249
9.6.5　习题 250
9.7　PHP 250
9.7.1　PHP基础 250
9.7.2　数组 251
9.7.3　PEAR DB库 251
9.7.4　使用DB创建数据库连接 251
9.7.5　执行SQL语句 251
9.7.6　PHP中的游标操作 252
9.7.7　PHP中的动态SQL 252
9.7.8　习题 253
9.8　小结 253
9.9　参考文献 254
第10章　关系数据库的新课题 255
10.1　SQL中的安全机制和用户认证 255
10.1.1　权限 255
10.1.2　创建权限 256
10.1.3　检查权限的过程 257
10.1.4　授权 257
10.1.5　授权图 258
10.1.6　收权 259
10.1.7　习题 262
10.2　SQL中的递归 262
10.2.1　在SQL中定义递归关系 262
10.2.2　有问题的递归SQL表达式 264
10.2.3　习题 266
10.3　对象关系模型 267
10.3.1　从关系到对象关系 267
10.3.2　嵌套关系 267
10.3.3　引用 268
10.3.4　面向对象与对象关系的比较 269
10.3.5　习题 270
10.4　SQL中的用户定义类型 270
10.4.1　在SQL中定义类型 270
10.4.2　用户定义类型中的方法声明 271
10.4.3　方法定义 272
10.4.4　用UDT声明关系 272
10.4.5　引用 272
10.4.6　为表生成对象标识符 273
10.4.7　习题 274
10.5　对象关系数据上的操作 274
10.5.1　引用的跟随 274
10.5.2　访问UDT类型的元组分量 275
10.5.3　生成器和转换器函数 276
10.5.4　UDT上联系的排序 277
10.5.5　习题 278
10.6　联机分析处理 279
10.6.1　OLAP和数据仓库 279
10.6.2　OLAP应用 279
10.6.3　OLAP数据的多维视图 280
10.6.4　星型模式 280
10.6.5　切片和切块 281
10.6.6　习题 283
10.7　数据立方体 283
10.7.1　立方体算子 284
10.7.2　SQL中的立方体算子 285
10.7.3　习题 286
10.8　小结 286
10.9　参考文献 287
第三部分　半结构化数据的建模和程序设计
第11章　半结构化数据模型 289
11.1　半结构化数据 289
11.1.1　为何需要半结构化数据模型 289
11.1.2　半结构化数据表示 290
11.1.3　信息集成与半结构化数据 291
11.1.4　习题 292
11.2　XML 292
11.2.1　语义标签 292
11.2.2　有模式和无模式的XML 292
11.2.3　格式规范的XML 292
11.2.4　属性 294
11.2.5　连接元素的属性 294
11.2.6　命名空间 295
11.2.7　XML和数据库 295
11.2.8　习题 296
11.3　文档类型定义 296
11.3.1　DTD的格式 296
11.3.2　使用DTD 299
11.3.3　属性列表 299
11.3.4　标识符和引用 299
11.3.5　习题 300
11.4　XML模式 301
11.4.1　XML模式的格式 301
11.4.2　元素 301
11.4.3　复杂类型 302
11.4.4　属性 303
11.4.5　受限的简单类型 304
11.4.6　XML模式中的键 305
11.4.7　XML模式中的外键 306
11.4.8　习题 308
11.5　小结 308
11.6　参考文献 309
第12章　XML程序设计语言 310
12.1　XPath 310
12.1.1　XPath数据模型 310
12.1.2　文档节点 311
12.1.3　路径表达式 311
12.1.4　相对路径表达式 312
12.1.5　路径表达式中的属性 312
12.1.6　轴 312
12.1.7　表达式的上下文 313
12.1.8　通配符 313
12.1.9　路径表达式中的条件 314
12.1.10　习题 315
12.2　XQuery 316
12.2.1　XQuery基础 317
12.2.2　FLWR表达式 318
12.2.3　通过变量的值置换变量 320
12.2.4　XQuery中的连接 321
12.2.5　XQuery比较操作符 322
12.2.6　消除重复 323
12.2.7　XQuery中的量词 323
12.2.8　聚集 324
12.2.9　XQuery表达式中的分支 324
12.2.10　查询结果排序 324
12.2.11　习题 325
12.3　扩展样式表语言 326
12.3.1　XSLT基础 326
12.3.2　模板 326
12.3.3　从XML数据中获取值 327
12.3.4　模板的递归应用 328
12.3.5　XSLT中的迭代 329
12.3.6　XSLT中的条件 330
12.3.7　习题 331
12.4　小结 332
12.5　参考文献 332
